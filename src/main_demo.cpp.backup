#include <SDL3/SDL.h>
#include <SDL3/SDL_vulkan.h>
#include <iostream>
#include <chrono>
#include "vulkan_renderer.h"
#include "PolygonFactory.h"
#include "ecs/world.hpp"
#include "ecs/systems/render_system.cpp"
#include "ecs/systems/physics_system.hpp"
#include "ecs/system_scheduler.hpp"
#include "ecs/profiler.hpp"
#include "ecs/change_detection.hpp"

// Demonstration of battle-ready ECS with thousands of entities
int main(int argc, char* argv[]) {
    constexpr int TARGET_FPS = 60;
    constexpr float TARGET_FRAME_TIME = 1.0f / TARGET_FPS;
    constexpr size_t ENTITY_COUNT = 5000; // Stress test with 5000 entities
    
    if (!SDL_Init(SDL_INIT_VIDEO)) {
        std::cerr << "Failed to initialize SDL: " << SDL_GetError() << std::endl;
        return -1;
    }

    // Check Vulkan support
    uint32_t extensionCount = 0;
    const char* const* extensions = SDL_Vulkan_GetInstanceExtensions(&extensionCount);
    if (!extensions || extensionCount == 0) {
        std::cerr << "Vulkan is not supported or no Vulkan extensions available" << std::endl;
        SDL_Quit();
        return -1;
    }

    SDL_Window* window = SDL_CreateWindow(
        "Fractalia2 - Battle-Ready ECS Demo",
        800, 600,
        SDL_WINDOW_VULKAN | SDL_WINDOW_RESIZABLE
    );

    if (!window) {
        std::cerr << "Failed to create window: " << SDL_GetError() << std::endl;
        SDL_Quit();
        return -1;
    }

    VulkanRenderer renderer;
    if (!renderer.initialize(window)) {
        std::cerr << "Failed to initialize Vulkan renderer" << std::endl;
        SDL_DestroyWindow(window);
        SDL_Quit();
        return -1;
    }

    // Initialize battle-ready ECS
    World world;
    SystemScheduler scheduler(world.getFlecsWorld());
    ChangeDetectionSystem changeDetection;
    
    // Configure profiler
    Profiler::getInstance().setTargetFrameTime(TARGET_FRAME_TIME);
    
    // Register systems with scheduler
    auto renderSystem = std::make_unique<RenderSystem>(&renderer, world.getFlecsWorld());
    
    // Register physics systems directly with flecs (simpler for this demo)
    world.getFlecsWorld().system<Transform, Velocity>()
        .each(movement_system);
        
    world.getFlecsWorld().system<Lifetime>()
        .each(lifetime_system);

    // Create test entities using the entity factory
    std::cout << "Creating " << ENTITY_COUNT << " entities..." << std::endl;
    
    auto entities = world.getEntityFactory().createSwarm(
        ENTITY_COUNT, 
        glm::vec3(0.0f, 0.0f, 0.0f), 
        1.5f  // radius
    );
    
    std::cout << "Created " << entities.size() << " entities successfully!" << std::endl;
    
    // Add some static entities for comparison
    for (int i = 0; i < 10; ++i) {
        auto staticEntity = world.getEntityFactory().createTriangle(
            glm::vec3(-1.8f + i * 0.2f, -1.8f, 0.0f),
            glm::vec4(0.0f, 1.0f, 0.0f, 1.0f),
            1  // higher layer
        );
        staticEntity.add<Static>();
    }

    bool running = true;
    SDL_Event event;
    
    // Performance monitoring
    int frameCount = 0;
    auto lastReportTime = std::chrono::high_resolution_clock::now();
    auto lastFrameTime = std::chrono::high_resolution_clock::now();
    
    std::cout << "Starting main loop with " << ENTITY_COUNT << " dynamic entities..." << std::endl;
    
    while (running) {
        PROFILE_BEGIN_FRAME();
        auto frameStartTime = std::chrono::high_resolution_clock::now();
        
        // Handle events
        {
            PROFILE_SCOPE("Event Processing");
            while (SDL_PollEvent(&event)) {
                if (event.type == SDL_EVENT_QUIT) {
                    running = false;
                }
                if (event.type == SDL_EVENT_KEY_DOWN) {
                    if (event.key.key == SDLK_ESCAPE) {
                        running = false;
                    } else if (event.key.key == SDLK_P) {
                        // Print performance report
                        Profiler::getInstance().printReport();
                    } else if (event.key.key == SDLK_R) {
                        // Reset profiler
                        Profiler::getInstance().reset();
                        std::cout << "Profiler reset" << std::endl;
                    }
                }
            }
        }
        
        // Calculate delta time
        float deltaTime = std::chrono::duration<float>(frameStartTime - lastFrameTime).count();
        lastFrameTime = frameStartTime;
        
        // Update ECS world
        {
            PROFILE_SCOPE("ECS Update");
            world.progress(deltaTime);
        }
        
        // Update render system
        {
            PROFILE_SCOPE("Render System");
            renderSystem->update();
        }
        
        // Draw frame
        {
            PROFILE_SCOPE("Vulkan Rendering");
            renderer.drawFrame();
        }
        
        // Update memory usage for profiler
        auto memStats = world.getMemoryManager().getStats();
        Profiler::getInstance().updateMemoryUsage(memStats.totalAllocated);
        
        frameCount++;
        PROFILE_END_FRAME();
        
        // Periodic performance reporting
        auto now = std::chrono::high_resolution_clock::now();
        if (std::chrono::duration<float>(now - lastReportTime).count() >= 5.0f) {
            lastReportTime = now;
            
            // Print basic performance stats every 5 seconds
            float avgFrameTime = Profiler::getInstance().getFrameTime();
            std::cout << "Frame " << frameCount 
                      << ": Avg " << avgFrameTime << "ms"
                      << " (" << (1000.0f / avgFrameTime) << " FPS)"
                      << " | Memory: " << (memStats.totalAllocated / 1024) << "KB"
                      << " | Entities: " << memStats.activeEntities 
                      << std::endl;
        }
        
        // Frame rate limiting
        auto frameEndTime = std::chrono::high_resolution_clock::now();
        float frameTime = std::chrono::duration<float>(frameEndTime - frameStartTime).count();
        if (frameTime < TARGET_FRAME_TIME) {
            int delayMs = static_cast<int>((TARGET_FRAME_TIME - frameTime) * 1000.0f);
            if (delayMs > 0) {
                SDL_Delay(delayMs);
            }
        }
    }

    // Final performance report
    std::cout << "\nFinal Performance Report:" << std::endl;
    Profiler::getInstance().printReport();
    
    // Export detailed profiling data
    Profiler::getInstance().exportToCSV("performance_report.csv");
    std::cout << "Detailed performance data exported to performance_report.csv" << std::endl;

    // Cleanup
    renderer.cleanup();
    SDL_DestroyWindow(window);
    SDL_Quit();

    return 0;
}