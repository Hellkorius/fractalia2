#version 450

layout(local_size_x = 64) in;

// Movement types
#define MOVEMENT_PETAL 0
#define MOVEMENT_ORBIT 1
#define MOVEMENT_WAVE 2
#define MOVEMENT_TRIANGLE_FORMATION 3

// Transition system constants
#define TRANSITION_DURATION 2.0  // Total transition time in seconds
#define TRANSITION_TO_ORIGIN 0.0   // Phase 0: Moving to origin (0,0)
#define TRANSITION_TO_TARGET 1.0   // Phase 1: Moving from origin to target center
#define ORGANIC_TRANSITION_DURATION 1.0  // Organic transition time
#define ORGANIC_TRANSITION_MARKER 1000.0 // Special marker for organic mode
#define SPAWN_LERP_DURATION 0.5  // Time to lerp from spawn to pattern position

// Entity states
#define STATE_SPAWN_LERP 0.0
#define STATE_NORMAL 1.0
#define STATE_ANGEL_TRANSITION 2.0
#define STATE_ORGANIC_TRANSITION 3.0

// GPU entity structure - matches CPU-side GPUEntity
struct GPUEntity {
    mat4 modelMatrix;        // Transform matrix
    vec4 color;              // RGBA color
    vec4 movementParams0;    // amplitude, frequency, phase, timeOffset  
    vec4 movementParams1;    // center.xyz, movementType
    vec4 runtimeState;       // totalTime, initialized, stateTimer, entityState
};

// Storage buffers - double buffered for compute/graphics
layout(set = 0, binding = 0, std430) restrict buffer EntityBufferIn {
    GPUEntity entitiesIn[];
};

layout(set = 0, binding = 1, std430) restrict buffer EntityBufferOut {
    GPUEntity entitiesOut[];
};

// Push constants for frame data
layout(push_constant) uniform PushConstants {
    float deltaTime;
    uint entityCount;
} pc;

// Movement pattern implementations
vec3 computePetalMovement(vec3 center, float amplitude, float frequency, float phase, float totalTime) {
    // Smooth radial oscillation from center
    float radialOscillation = 0.5 + 0.5 * sin(totalTime * frequency * 0.3);
    float currentRadius = amplitude * radialOscillation;
    
    // Petal angle rotation
    float petalAngle = totalTime * frequency + phase;
    
    return center + vec3(
        currentRadius * cos(petalAngle),
        currentRadius * sin(petalAngle),
        0.0
    );
}

vec3 computeOrbitMovement(vec3 center, float amplitude, float frequency, float phase, float totalTime) {
    // Circular orbit around center
    float angle = totalTime * frequency + phase;
    return center + vec3(
        amplitude * cos(angle),
        amplitude * sin(angle),
        0.0
    );
}

vec3 computeWaveMovement(vec3 center, float amplitude, float frequency, float phase, float totalTime) {
    // Sinusoidal wave movement
    float wave = sin(totalTime * frequency + phase);
    return center + vec3(
        amplitude * wave,
        amplitude * cos(totalTime * frequency * 0.5 + phase),
        0.0
    );
}

vec3 computeTriangleFormation(vec3 center, float amplitude, float frequency, float phase, float totalTime) {
    // Non-Euclidean triangular orbit around origin
    float orbitRadius = amplitude * 2.0;
    
    // Primary orbital motion around origin (like orbit movement)
    float orbitAngle = totalTime * frequency + phase;
    vec3 orbitPosition = vec3(
        orbitRadius * cos(orbitAngle),
        orbitRadius * sin(orbitAngle),
        0.0
    );
    
    // Add triangular warping to the orbit path
    // Create 3 "nodes" in the orbit that correspond to triangle vertices
    float trianglePhase = orbitAngle * 1.5; // 1.5x faster creates triangular resonance
    float triangleWarp = sin(trianglePhase) * 0.4; // Triangular warping strength
    
    // Apply triangular distortion to the circular orbit
    float warpedRadius = orbitRadius * (1.0 + triangleWarp);
    vec3 triangularOrbit = vec3(
        warpedRadius * cos(orbitAngle),
        warpedRadius * sin(orbitAngle),
        0.0
    );
    
    // Add non-Euclidean effects
    float cosmicTime = totalTime * frequency + phase;
    
    // Add dimensional folding: entities occasionally "fold" through higher dimensions
    float foldingPhase = sin(cosmicTime * 0.7 + phase * 2.0);
    float dimensionalFold = pow(abs(foldingPhase), 3.0) * sign(foldingPhase);
    
    // Add interweaving radial oscillation (like petal movement)
    float radialOscillation = 0.5 + 0.5 * sin(totalTime * frequency * 0.3 + phase * 2.0);
    float interweavingScale = 0.8 + 0.4 * radialOscillation; // Entities weave in and out
    
    // Add hyperbolic curvature to the orbital path
    float distanceFromCenter = length(triangularOrbit);
    float curvature = sin(orbitAngle * 3.0 + totalTime * frequency * 0.3) * orbitRadius * 0.1;
    vec3 curvatureVector = vec3(-sin(orbitAngle), cos(orbitAngle), 0.0) * curvature;
    
    // Apply all transformations to create non-Euclidean triangular orbit
    vec3 finalPosition = triangularOrbit * interweavingScale + curvatureVector;
    finalPosition += vec3(dimensionalFold * 0.1, dimensionalFold * 0.15, 0.0);
    
    return center + finalPosition;
}

// Smooth transition system - entities move to origin, then to new center (Angel Mode)
vec3 computeTransitionMovement(vec3 currentPos, vec3 targetCenter, float transitionTime, float transitionPhase) {
    float halfDuration = TRANSITION_DURATION * 0.5;
    
    if (transitionPhase < 0.5) {
        // Phase 0: Move from current position to origin (0,0)
        float t = clamp(transitionTime / halfDuration, 0.0, 1.0);
        // Smooth easing function (ease-in-out)
        t = t * t * (3.0 - 2.0 * t);
        return mix(currentPos, vec3(0.0, 0.0, 0.0), t);
    } else {
        // Phase 1: Move from origin to target center
        float t = clamp((transitionTime - halfDuration) / halfDuration, 0.0, 1.0);
        // Smooth easing function (ease-in-out)
        t = t * t * (3.0 - 2.0 * t);
        return mix(vec3(0.0, 0.0, 0.0), targetCenter, t);
    }
}

// Organic transition system - entities move directly to their target position in the new pattern
vec3 computeOrganicTransition(vec3 currentPos, vec3 targetPos, float transitionTime) {
    float t = clamp(transitionTime / ORGANIC_TRANSITION_DURATION, 0.0, 1.0);
    // Smooth easing function (ease-in-out)
    t = t * t * (3.0 - 2.0 * t);
    return mix(currentPos, targetPos, t);
}

// Dynamic color generation based on movement
vec4 generateDynamicColor(float amplitude, float frequency, float phase, float totalTime) {
    // HSV-style color generation
    float hue = mod(phase + totalTime * 0.5, 6.28318530718) / 6.28318530718;
    float saturation = 0.7 + 0.3 * sin(frequency * totalTime);
    float brightness = 0.8 + 0.2 * sin(amplitude * totalTime * 0.5);
    
    // Convert HSV to RGB
    float c = brightness * saturation;
    float x = c * (1.0 - abs(mod(hue * 6.0, 2.0) - 1.0));
    float m = brightness - c;
    
    vec3 rgb;
    if (hue < 1.0/6.0) rgb = vec3(c, x, 0);
    else if (hue < 2.0/6.0) rgb = vec3(x, c, 0);
    else if (hue < 3.0/6.0) rgb = vec3(0, c, x);
    else if (hue < 4.0/6.0) rgb = vec3(0, x, c);
    else if (hue < 5.0/6.0) rgb = vec3(x, 0, c);
    else rgb = vec3(c, 0, x);
    
    return vec4(rgb + m, 1.0);
}

void main() {
    uint index = gl_GlobalInvocationID.x;
    
    // Bounds check
    if (index >= pc.entityCount) {
        return;
    }
    
    // Read input entity
    GPUEntity entity = entitiesIn[index];
    
    // Update runtime state
    float totalTime = entity.runtimeState.x + pc.deltaTime;
    bool initialized = entity.runtimeState.y > 0.5;
    float stateTimer = entity.runtimeState.z;
    float entityState = entity.runtimeState.w;
    
    // Extract movement parameters
    float amplitude = entity.movementParams0.x;
    float frequency = entity.movementParams0.y;
    float phase = entity.movementParams0.z;
    float timeOffset = entity.movementParams0.w;
    vec3 center = entity.movementParams1.xyz;
    uint movementType = uint(entity.movementParams1.w);
    
    // Get current position
    vec3 currentPos = vec3(entity.modelMatrix[3][0], entity.modelMatrix[3][1], entity.modelMatrix[3][2]);
    
    // Initialize on first frame
    if (!initialized) {
        initialized = true;
        entityState = STATE_SPAWN_LERP;
        stateTimer = 0.0;
        // Center is already correctly set from CPU with mouse click position
    }
    
    // Apply time offset
    float adjustedTime = totalTime + timeOffset;
    
    vec3 newPosition;
    
    // State machine
    if (entityState == STATE_SPAWN_LERP) {
        // Spawn lerp: entity lerps from spawn position to pattern position
        stateTimer += pc.deltaTime;
        
        // Calculate where entity should be in movement pattern
        vec3 targetPatternPosition;
        switch (movementType) {
            case MOVEMENT_PETAL:
                targetPatternPosition = computePetalMovement(center, amplitude, frequency, phase, adjustedTime);
                break;
            case MOVEMENT_ORBIT:
                targetPatternPosition = computeOrbitMovement(center, amplitude, frequency, phase, adjustedTime);
                break;
            case MOVEMENT_WAVE:
                targetPatternPosition = computeWaveMovement(center, amplitude, frequency, phase, adjustedTime);
                break;
            case MOVEMENT_TRIANGLE_FORMATION:
                targetPatternPosition = computeTriangleFormation(center, amplitude, frequency, phase, adjustedTime);
                break;
            default:
                targetPatternPosition = computePetalMovement(center, amplitude, frequency, phase, adjustedTime);
                break;
        }
        
        // Lerp from spawn position (center) to pattern position
        float t = clamp(stateTimer / SPAWN_LERP_DURATION, 0.0, 1.0);
        t = t * t * (3.0 - 2.0 * t); // Smooth step easing
        newPosition = mix(center, targetPatternPosition, t);
        
        // Check if spawn lerp is complete
        if (stateTimer >= SPAWN_LERP_DURATION) {
            entityState = STATE_NORMAL;
            stateTimer = 0.0;
        }
    }
    else if (entityState == STATE_ANGEL_TRANSITION) {
        // Angel Mode: Biblical transition via origin
        stateTimer += pc.deltaTime;
        
        float transitionPhase = (stateTimer >= TRANSITION_DURATION * 0.5) ? 1.0 : 0.0;
        
        // Compute transition movement
        newPosition = computeTransitionMovement(currentPos, center, stateTimer, transitionPhase);
        
        // Check if transition is complete
        if (stateTimer >= TRANSITION_DURATION) {
            entityState = STATE_NORMAL;
            stateTimer = 0.0;
            // Update center to origin for new movement pattern
            center = vec3(0.0, 0.0, 0.0);
            entity.movementParams1.xyz = center;
        }
    }
    else if (entityState == STATE_ORGANIC_TRANSITION) {
        // Organic Mode: Direct transition to target position
        stateTimer += pc.deltaTime;
        
        // Calculate where the entity should be in the new movement pattern
        vec3 targetPosition;
        switch (movementType) {
            case MOVEMENT_PETAL:
                targetPosition = computePetalMovement(center, amplitude, frequency, phase, adjustedTime);
                break;
            case MOVEMENT_ORBIT:
                targetPosition = computeOrbitMovement(center, amplitude, frequency, phase, adjustedTime);
                break;
            case MOVEMENT_WAVE:
                targetPosition = computeWaveMovement(center, amplitude, frequency, phase, adjustedTime);
                break;
            case MOVEMENT_TRIANGLE_FORMATION:
                targetPosition = computeTriangleFormation(center, amplitude, frequency, phase, adjustedTime);
                break;
            default:
                targetPosition = computePetalMovement(center, amplitude, frequency, phase, adjustedTime);
                break;
        }
        
        // Compute organic transition movement
        newPosition = computeOrganicTransition(currentPos, targetPosition, stateTimer);
        
        // Check if organic transition is complete
        if (stateTimer >= ORGANIC_TRANSITION_DURATION) {
            entityState = STATE_NORMAL;
            stateTimer = 0.0;
        }
    }
    else { // STATE_NORMAL
        // Normal movement pattern computation
        switch (movementType) {
            case MOVEMENT_PETAL:
                newPosition = computePetalMovement(center, amplitude, frequency, phase, adjustedTime);
                break;
            case MOVEMENT_ORBIT:
                newPosition = computeOrbitMovement(center, amplitude, frequency, phase, adjustedTime);
                break;
            case MOVEMENT_WAVE:
                newPosition = computeWaveMovement(center, amplitude, frequency, phase, adjustedTime);
                break;
            case MOVEMENT_TRIANGLE_FORMATION:
                newPosition = computeTriangleFormation(center, amplitude, frequency, phase, adjustedTime);
                break;
            default:
                newPosition = computePetalMovement(center, amplitude, frequency, phase, adjustedTime);
                break;
        }
    }
    
    // Calculate rotation based on amplitude (more amplitude = faster rotation)
    float rotationSpeed = amplitude * 0.1; // Elegant, gentle scaling factor
    float rotation = adjustedTime * rotationSpeed;
    
    // Create rotation matrix (Z-axis rotation for 2D)
    float cosR = cos(rotation);
    float sinR = sin(rotation);
    
    // Update transform matrix with rotation and position
    entity.modelMatrix[0][0] = cosR;  // Scale X by cos
    entity.modelMatrix[0][1] = sinR;  // Shear Y by sin  
    entity.modelMatrix[1][0] = -sinR; // Shear X by -sin
    entity.modelMatrix[1][1] = cosR;  // Scale Y by cos
    entity.modelMatrix[3][0] = newPosition.x; // Translation X
    entity.modelMatrix[3][1] = newPosition.y; // Translation Y
    entity.modelMatrix[3][2] = newPosition.z; // Translation Z
    
    // Update dynamic color
    entity.color = generateDynamicColor(amplitude, frequency, phase, adjustedTime);
    
    // Update runtime state
    entity.runtimeState.x = totalTime;
    entity.runtimeState.y = initialized ? 1.0 : 0.0;
    entity.runtimeState.z = stateTimer;
    entity.runtimeState.w = entityState;
    
    // Write to output buffer
    entitiesOut[index] = entity;
}