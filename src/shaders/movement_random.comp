#version 450

// Local workgroup size - optimize for GPU architecture
layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

// Push constants for timing and control
layout(push_constant) uniform ComputePushConstants {
    float time;
    float deltaTime;
    uint entityCount;
    uint frame;
} pc;

// Input: GPUEntity buffer (read-only)
layout(std430, binding = 0) readonly buffer GPUEntityBuffer {
    // GPUEntity structure (128 bytes each)
    // mat4 modelMatrix (64 bytes) - positions 0-3
    // vec4 color (16 bytes) - position 4  
    // vec4 movementParams0 (16 bytes) - position 5: amplitude, frequency, phase, timeOffset
    // vec4 movementParams1 (16 bytes) - position 6: center.xyz, movementType
    // vec4 runtimeState (16 bytes) - position 7: totalTime, initialized, stateTimer, entityState
    vec4 entityData[];
} entities;

// Output: Computed positions (write-only)
layout(std430, binding = 1) writeonly buffer PositionBuffer {
    vec4 positions[]; // xyz position + w unused
} outPositions;

/* ---------- Random Movement Functions ---------- */

// Wang hash function for high-quality GPU pseudorandom generation
uint wangHash(uint seed) {
    seed = (seed ^ 61u) ^ (seed >> 16u);
    seed *= 9u;
    seed = seed ^ (seed >> 4u);
    seed *= 0x27d4eb2du;
    seed = seed ^ (seed >> 15u);
    return seed;
}

// Convert hash to normalized float [0.0, 1.0]
float hashToFloat(uint hash) {
    return float(hash) / 4294967295.0;
}

// Generate pseudorandom float in range [0.0, 1.0] from seed
float pseudoRandom(uint seed) {
    return hashToFloat(wangHash(seed));
}

// Random step movement pattern
vec3 randomStep(vec3 center, float amplitude, float frequency, float phase, float time, uint entityId) {
    // Step frequency determines how often entities change direction
    float stepInterval = 1.0 / max(frequency, 0.1);
    float stepTime = floor(time / stepInterval);
    
    // Create unique seed for this entity at this step time
    uint baseSeed = entityId ^ uint(stepTime * 1000.0) ^ uint(phase * 10000.0);
    
    // Generate entity-specific drift characteristics
    uint entitySeed = entityId ^ 0x12345678u;
    float driftiness = pseudoRandom(entitySeed); // 0.0 = stays close, 1.0 = drifts far
    float explorationTendency = pseudoRandom(entitySeed + 1u); // How adventurous this entity is
    
    // Calculate dynamic drift parameters based on entity personality
    float maxDriftMultiplier = 3.0 + driftiness * 12.0; // Range: 3x to 15x amplitude
    float centerPullStrength = 0.005 + (1.0 - driftiness) * 0.02; // Stronger pull for less drifty entities
    
    // Generate multiple accumulated steps for smooth random walk
    vec3 totalOffset = vec3(0.0);
    
    // Vary number of accumulated steps based on exploration tendency
    int numSteps = int(6.0 + explorationTendency * 10.0); // 6-16 steps
    
    for (int i = 0; i < numSteps; i++) {
        uint stepSeed = baseSeed + uint(i * 7919); // Prime for good distribution
        
        // Generate random direction (angle)
        float randAngle = pseudoRandom(stepSeed) * 6.28318530718; // 2Ï€
        
        // Generate random step magnitude with varied decay
        float stepDecay = 1.0 - (float(i) / float(numSteps)) * (0.2 + explorationTendency * 0.3);
        float stepMagnitude = pseudoRandom(stepSeed + 31u) * amplitude * stepDecay;
        
        // Add exploration boost for adventurous entities
        stepMagnitude *= (1.0 + explorationTendency * 0.5);
        
        // Calculate step vector
        vec3 stepVector = vec3(
            stepMagnitude * cos(randAngle),
            stepMagnitude * sin(randAngle),
            0.0
        );
        
        totalOffset += stepVector;
    }
    
    // Apply dynamic boundary constraints based on entity drift characteristics
    float maxDistance = amplitude * maxDriftMultiplier;
    float currentDistance = length(totalOffset);
    
    // Soft boundary with some randomness - occasionally allow exceeding bounds
    float boundaryRandomness = pseudoRandom(baseSeed + 999u);
    float effectiveMaxDistance = maxDistance * (0.8 + boundaryRandomness * 0.4); // 80%-120% of max
    
    if (currentDistance > effectiveMaxDistance) {
        // Softer constraint - compress rather than hard clamp
        float compressionFactor = effectiveMaxDistance / currentDistance;
        compressionFactor = sqrt(compressionFactor); // Gentler compression
        totalOffset *= compressionFactor;
    }
    
    // Add dynamic drift back toward center based on entity personality
    vec3 centerPull = -totalOffset * centerPullStrength;
    
    // Occasionally resist center pull for very drifty entities
    if (driftiness > 0.7 && pseudoRandom(baseSeed + 777u) > 0.6) {
        centerPull *= 0.3; // Reduce center pull strength
    }
    
    totalOffset += centerPull;
    
    return center + totalOffset;
}

void main() {
    // Get current entity index
    uint entityIndex = gl_GlobalInvocationID.x;
    
    // Bounds check
    if (entityIndex >= pc.entityCount) {
        return;
    }
    
    // Calculate base offset for this entity (8 vec4s per entity = 128 bytes)
    uint baseOffset = entityIndex * 8;
    
    // Extract movement parameters from GPUEntity structure
    // movementParams0: amplitude, frequency, phase, timeOffset
    vec4 movementParams0 = entities.entityData[baseOffset + 5];
    float amplitude = movementParams0.x;
    float frequency = movementParams0.y;
    float phase = movementParams0.z;
    float timeOffset = movementParams0.w;
    
    // movementParams1: center.xyz, movementType
    vec4 movementParams1 = entities.entityData[baseOffset + 6];
    vec3 center = movementParams1.xyz;
    
    // Calculate entity time
    float entityTime = pc.time + timeOffset;
    
    // Compute random walk position
    vec3 newPosition = randomStep(center, amplitude, frequency, phase, entityTime, entityIndex);
    
    // Write computed position to output buffer
    outPositions.positions[entityIndex] = vec4(newPosition, 1.0);
}