#version 450

// Local workgroup size - optimized for better occupancy on most GPUs
layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

// Push constants for timing and control
layout(push_constant) uniform ComputePushConstants {
    float time;
    float deltaTime;
    uint entityCount;
    uint frame;
} pc;

// Input: GPUEntity buffer (read/write for state updates)
layout(std430, binding = 0) buffer GPUEntityBuffer {
    // Cache-optimized GPUEntity structure (128 bytes each):
    // C++ struct layout matches this comment:
    //   vec4 movementParams0 (16 bytes) - position 0: amplitude, frequency, phase, timeOffset
    //   vec4 movementParams1 (16 bytes) - position 1: center.xyz, movementType  
    //   vec4 runtimeState (16 bytes) - position 2: totalTime, initialized, stateTimer, entityState
    //   vec4 color (16 bytes) - position 3: RGBA color
    //   mat4 modelMatrix (64 bytes) - positions 4-7: transform matrix (graphics only)
    vec4 entityData[];
} entities;

// Output: Computed positions (write-only) - not used for random movement
layout(std430, binding = 1) writeonly buffer PositionBuffer {
    vec4 positions[]; // xyz position + w unused
} outPositions;

// Current positions for interpolation (read/write)
layout(std430, binding = 2) buffer CurrentPositionBuffer {
    vec4 currentPositions[]; // xyz current position + w unused
} currentPos;

// Target positions for interpolation (read/write)
layout(std430, binding = 3) buffer TargetPositionBuffer {
    vec4 targetPositions[]; // xyz target position + w unused
} targetPos;

/* ---------- Random Walk Movement Functions ---------- */

// Constants for improved readability
const float TWO_PI = 6.28318530718;
const uint CYCLE_LENGTH = 600u;

// Wang hash function for high-quality GPU pseudorandom generation
uint wangHash(uint seed) {
    seed = (seed ^ 61u) ^ (seed >> 16u);
    seed *= 9u;
    seed = seed ^ (seed >> 4u);
    seed *= 0x27d4eb2du;
    seed = seed ^ (seed >> 15u);
    return seed;
}

// Convert hash to normalized float [0.0, 1.0]
float hashToFloat(uint hash) {
    return float(hash) / 4294967295.0;
}

// Generate pseudorandom float in range [0.0, 1.0] from seed
float pseudoRandom(uint seed) {
    return hashToFloat(wangHash(seed));
}

// Pure random step movement pattern - no center constraints
vec3 randomStep(vec3 center, float amplitude, float frequency, float phase, float time, uint entityId) {
    // Step frequency determines how often entities change direction
    float stepInterval = 1.0 / max(frequency, 0.1);
    float stepTime = floor(time / stepInterval);
    
    // Create unique seed for this entity at this step time
    uint baseSeed = entityId ^ uint(stepTime * 1000.0) ^ uint(phase * 10000.0);
    
    // Generate entity-specific characteristics
    uint entitySeed = entityId ^ 0x12345678u;
    float driftiness = pseudoRandom(entitySeed); // Entity exploration factor
    
    // Single random step
    float randAngle = pseudoRandom(baseSeed) * TWO_PI;
    float stepMagnitude = pseudoRandom(baseSeed + 31u) * amplitude;
    
    // Moderate exploration boost for natural movement
    stepMagnitude *= (2.0 + driftiness * 1.0);
    
    // Calculate step vector - pure random movement
    vec3 stepOffset = vec3(
        stepMagnitude * cos(randAngle),
        stepMagnitude * sin(randAngle),
        0.0
    );
    
    return center + stepOffset;
}

void main() {
    // Get current entity index
    uint entityIndex = gl_GlobalInvocationID.x;
    
    // Bounds check
    if (entityIndex >= pc.entityCount) {
        return;
    }
    
    // Calculate base offset for this entity (8 vec4s per entity = 128 bytes)
    uint baseOffset = entityIndex * 8;
    
    // Extract movement parameters from GPUEntity structure
    // Actual C++ layout: movementParams0 + movementParams1 + runtimeState + color + modelMatrix(4 vec4s)
    // movementParams0: amplitude, frequency, phase, timeOffset
    vec4 movementParams0 = entities.entityData[baseOffset + 0];
    float amplitude = movementParams0.x;
    float frequency = movementParams0.y;
    float phase = movementParams0.z;
    float timeOffset = movementParams0.w;
    
    // movementParams1: center.xyz, movementType
    vec4 movementParams1 = entities.entityData[baseOffset + 1];
    vec3 center = movementParams1.xyz;
    // movementType is always 0.0 for random walk - no need to extract
    
    // Calculate cycle using frame number and entity offset for staggering
    float cycle = mod(pc.frame + entityIndex * 37u, float(CYCLE_LENGTH));
    
    // Extract runtime state from GPUEntity
    vec4 runtimeState = entities.entityData[baseOffset + 2]; // runtimeState at position 2
    float initialized = runtimeState.y; // initialized flag
    
    // Initialize buffers for new entities using the entity's initialized flag
    if (initialized < 0.5) { // Entity not yet initialized
        currentPos.currentPositions[entityIndex] = vec4(center, 1.0);
        targetPos.targetPositions[entityIndex] = vec4(center, 1.0);
        
        // Mark entity as initialized in GPU memory
        entities.entityData[baseOffset + 2].y = 1.0; // Set initialized flag
    }
    
    // Get current position and target
    vec3 currentPosition = currentPos.currentPositions[entityIndex].xyz;
    vec3 target = targetPos.targetPositions[entityIndex].xyz;
    
    // On cycle reset, generate new target position
    if (cycle < 1.0) {
        // Current position becomes the previous target (for continuity)
        if (pc.frame >= float(CYCLE_LENGTH)) { // Not the very first cycle
            currentPosition = target;
            currentPos.currentPositions[entityIndex] = vec4(currentPosition, 1.0);
        }
        
        // Generate new random step from current position
        uint cycleNumber = uint(pc.frame / float(CYCLE_LENGTH));
        // Ensure unique seed per entity per cycle - multiple prime multipliers prevent collisions
        uint baseSeed = entityIndex * 2654435761u + cycleNumber * 1597334677u + uint(phase * 982451653.0) + uint(amplitude * 1640531371.0);
        float randAngle = pseudoRandom(baseSeed) * TWO_PI;
        float stepMagnitude = pseudoRandom(baseSeed + 1u) * amplitude;
        
        // Apply moderate drift for natural movement without center clustering
        uint entitySeed = entityIndex ^ 0x12345678u;
        float driftiness = pseudoRandom(entitySeed);
        stepMagnitude *= (2.0 + driftiness * 1.0);
        
        vec3 randomStep = vec3(
            stepMagnitude * cos(randAngle),
            stepMagnitude * sin(randAngle),
            0.0
        );
        
        // New target is current position + random step
        target = currentPosition + randomStep;
        targetPos.targetPositions[entityIndex] = vec4(target, 1.0);
    }
    
    // Compute interpolated position and write to output
    float t = smoothstep(0.0, 1.0, cycle / float(CYCLE_LENGTH));
    vec3 interpolatedPosition = mix(currentPosition, target, t);
    outPositions.positions[entityIndex] = vec4(interpolatedPosition, 1.0);
}