#version 450

// Local workgroup size - optimize for GPU architecture
layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

// Push constants for timing and control
layout(push_constant) uniform ComputePushConstants {
    float time;
    float deltaTime;
    uint entityCount;
    uint frame;
} pc;

// Input: GPUEntity buffer (read/write for state updates)
layout(std430, binding = 0) buffer GPUEntityBuffer {
    // GPUEntity structure (128 bytes each)
    // mat4 modelMatrix (64 bytes) - positions 0-3
    // vec4 color (16 bytes) - position 4  
    // vec4 movementParams0 (16 bytes) - position 5: amplitude, frequency, phase, timeOffset
    // vec4 movementParams1 (16 bytes) - position 6: center.xyz, movementType
    // vec4 runtimeState (16 bytes) - position 7: totalTime, initialized, stateTimer, entityState
    vec4 entityData[];
} entities;

// Output: Computed positions (write-only) - not used for random movement
layout(std430, binding = 1) writeonly buffer PositionBuffer {
    vec4 positions[]; // xyz position + w unused
} outPositions;

// Current positions for interpolation (read/write)
layout(std430, binding = 2) buffer CurrentPositionBuffer {
    vec4 currentPositions[]; // xyz current position + w unused
} currentPos;

// Target positions for interpolation (read/write)
layout(std430, binding = 3) buffer TargetPositionBuffer {
    vec4 targetPositions[]; // xyz target position + w unused
} targetPos;

/* ---------- Traditional Movement Functions ---------- */

vec3 petal(vec3 center, float amplitude, float frequency, float phase, float time) {
    float r = amplitude * (0.5 + 0.5 * sin(time * frequency * 0.3));
    return center + vec3(r * cos(time * frequency + phase), r * sin(time * frequency + phase), 0);
}

vec3 orbit(vec3 center, float amplitude, float frequency, float phase, float time) {
    float ang = time * frequency + phase;
    return center + vec3(amplitude * cos(ang), amplitude * sin(ang), 0);
}

vec3 wave(vec3 center, float amplitude, float frequency, float phase, float time) {
    return center + vec3(amplitude * sin(time * frequency + phase), amplitude * cos(time * frequency * 0.5 + phase), 0);
}

vec3 triangle(vec3 center, float amplitude, float frequency, float phase, float time) {
    float ang = time * frequency + phase;
    float w = amplitude * 2.0 * (1.0 + 0.3 * sin(ang * 1.5));
    return center + vec3(w * cos(ang), w * sin(ang), 0);
}

/* ---------- Random Movement Functions ---------- */

// Wang hash function for high-quality GPU pseudorandom generation
uint wangHash(uint seed) {
    seed = (seed ^ 61u) ^ (seed >> 16u);
    seed *= 9u;
    seed = seed ^ (seed >> 4u);
    seed *= 0x27d4eb2du;
    seed = seed ^ (seed >> 15u);
    return seed;
}

// Convert hash to normalized float [0.0, 1.0]
float hashToFloat(uint hash) {
    return float(hash) / 4294967295.0;
}

// Generate pseudorandom float in range [0.0, 1.0] from seed
float pseudoRandom(uint seed) {
    return hashToFloat(wangHash(seed));
}

// Random step movement pattern
vec3 randomStep(vec3 center, float amplitude, float frequency, float phase, float time, uint entityId) {
    // Step frequency determines how often entities change direction
    float stepInterval = 1.0 / max(frequency, 0.1);
    float stepTime = floor(time / stepInterval);
    
    // Create unique seed for this entity at this step time
    uint baseSeed = entityId ^ uint(stepTime * 1000.0) ^ uint(phase * 10000.0);
    
    // Generate entity-specific drift characteristics
    uint entitySeed = entityId ^ 0x12345678u;
    float driftiness = pseudoRandom(entitySeed); // 0.0 = stays close, 1.0 = drifts far
    float explorationTendency = pseudoRandom(entitySeed + 1u); // How adventurous this entity is
    
    // Calculate dynamic drift parameters based on entity personality
    float maxDriftMultiplier = 3.0 + driftiness * 12.0; // Range: 3x to 15x amplitude
    float centerPullStrength = 0.005 + (1.0 - driftiness) * 0.02; // Stronger pull for less drifty entities
    
    // Generate multiple accumulated steps for smooth random walk
    vec3 totalOffset = vec3(0.0);
    
    // Vary number of accumulated steps based on exploration tendency
    int numSteps = int(6.0 + explorationTendency * 10.0); // 6-16 steps
    
    for (int i = 0; i < numSteps; i++) {
        uint stepSeed = baseSeed + uint(i * 7919); // Prime for good distribution
        
        // Generate random direction (angle)
        float randAngle = pseudoRandom(stepSeed) * 6.28318530718; // 2π
        
        // Generate random step magnitude with varied decay
        float stepDecay = 1.0 - (float(i) / float(numSteps)) * (0.2 + explorationTendency * 0.3);
        float stepMagnitude = pseudoRandom(stepSeed + 31u) * amplitude * stepDecay;
        
        // Add exploration boost for adventurous entities
        stepMagnitude *= (1.0 + explorationTendency * 0.5);
        
        // Calculate step vector
        vec3 stepVector = vec3(
            stepMagnitude * cos(randAngle),
            stepMagnitude * sin(randAngle),
            0.0
        );
        
        totalOffset += stepVector;
    }
    
    // Apply dynamic boundary constraints based on entity drift characteristics
    float maxDistance = amplitude * maxDriftMultiplier;
    float currentDistance = length(totalOffset);
    
    // Soft boundary with some randomness - occasionally allow exceeding bounds
    float boundaryRandomness = pseudoRandom(baseSeed + 999u);
    float effectiveMaxDistance = maxDistance * (0.8 + boundaryRandomness * 0.4); // 80%-120% of max
    
    if (currentDistance > effectiveMaxDistance) {
        // Softer constraint - compress rather than hard clamp
        float compressionFactor = effectiveMaxDistance / currentDistance;
        compressionFactor = sqrt(compressionFactor); // Gentler compression
        totalOffset *= compressionFactor;
    }
    
    // Add dynamic drift back toward center based on entity personality
    vec3 centerPull = -totalOffset * centerPullStrength;
    
    // Occasionally resist center pull for very drifty entities
    if (driftiness > 0.7 && pseudoRandom(baseSeed + 777u) > 0.6) {
        centerPull *= 0.3; // Reduce center pull strength
    }
    
    totalOffset += centerPull;
    
    return center + totalOffset;
}

void main() {
    // Get current entity index
    uint entityIndex = gl_GlobalInvocationID.x;
    
    // Bounds check
    if (entityIndex >= pc.entityCount) {
        return;
    }
    
    // Calculate base offset for this entity (8 vec4s per entity = 128 bytes)
    uint baseOffset = entityIndex * 8;
    
    // Extract movement parameters from GPUEntity structure
    // movementParams0: amplitude, frequency, phase, timeOffset
    vec4 movementParams0 = entities.entityData[baseOffset + 5];
    float amplitude = movementParams0.x;
    float frequency = movementParams0.y;
    float phase = movementParams0.z;
    float timeOffset = movementParams0.w;
    
    // movementParams1: center.xyz, movementType
    vec4 movementParams1 = entities.entityData[baseOffset + 6];
    vec3 center = movementParams1.xyz;
    float movementType = movementParams1.w;
    
    // Handle different movement types
    if (movementType != 4.0) {
        // Traditional movement patterns (0-3) - compute position directly
        float entityTime = pc.time + timeOffset;
        vec3 newPosition;
        
        uint movementTypeInt = uint(movementType);
        switch (movementTypeInt) {
            case 0:
                newPosition = petal(center, amplitude, frequency, phase, entityTime);
                break;
            case 1:
                newPosition = orbit(center, amplitude, frequency, phase, entityTime);
                break;
            case 2:
                newPosition = wave(center, amplitude, frequency, phase, entityTime);
                break;
            case 3:
                newPosition = triangle(center, amplitude, frequency, phase, entityTime);
                break;
            default:
                newPosition = center; // Fallback
                break;
        }
        
        outPositions.positions[entityIndex] = vec4(newPosition, 1.0);
        return;
    }
    
    // Calculate cycle using frame number and entity offset for staggering
    float cycle = mod(pc.frame + entityIndex * 37, 600.0);
    
    // Initialize buffers on very first frame
    if (pc.frame < 1.0) {
        currentPos.currentPositions[entityIndex] = vec4(center, 1.0);
        targetPos.targetPositions[entityIndex] = vec4(center, 1.0);
    }
    
    // Get current position and target
    vec3 currentPosition = currentPos.currentPositions[entityIndex].xyz;
    vec3 target = targetPos.targetPositions[entityIndex].xyz;
    
    // On cycle reset, generate new target position
    if (cycle < 1.0) {
        // Current position becomes the previous target (for continuity)
        if (pc.frame >= 600.0) { // Not the very first cycle
            currentPosition = target;
            currentPos.currentPositions[entityIndex] = vec4(currentPosition, 1.0);
        }
        
        // Generate new random step from current position
        uint cycleNumber = uint(pc.frame / 600.0);
        // Ensure unique seed per entity per cycle - multiple prime multipliers prevent collisions
        uint baseSeed = entityIndex * 2654435761u + cycleNumber * 1597334677u + uint(phase * 982451653.0) + uint(amplitude * 1640531371.0);
        float randAngle = pseudoRandom(baseSeed) * 6.28318530718; // 2π
        float stepMagnitude = pseudoRandom(baseSeed + 1u) * amplitude;
        
        vec3 randomStep = vec3(
            stepMagnitude * cos(randAngle),
            stepMagnitude * sin(randAngle),
            0.0
        );
        
        // New target is current position + random step
        target = currentPosition + randomStep;
        targetPos.targetPositions[entityIndex] = vec4(target, 1.0);
    }
    
    // Compute interpolated position and write to output
    float t = smoothstep(0.0, 1.0, cycle / 600.0);
    vec3 interpolatedPosition = mix(currentPosition, target, t);
    outPositions.positions[entityIndex] = vec4(interpolatedPosition, 1.0);
}