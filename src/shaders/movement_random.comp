#version 450

// Optimized workgroup size for maximum GPU occupancy
layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

// Push constants for timing and control
layout(push_constant) uniform ComputePushConstants {
    float time;
    float deltaTime;
    uint entityCount;
    uint frame;
    uint entityOffset;  // For chunked dispatches
} pc;

// Input: GPUEntity buffer (read/write for state updates)
layout(std430, binding = 0) buffer GPUEntityBuffer {
    // Cache-optimized GPUEntity structure (128 bytes each):
    // C++ struct layout matches this comment:
    //   vec4 movementParams0 (16 bytes) - position 0: amplitude, frequency, phase, timeOffset
    //   vec4 movementParams1 (16 bytes) - position 1: center.xyz, movementType  
    //   vec4 runtimeState (16 bytes) - position 2: totalTime, initialized, stateTimer, entityState
    //   vec4 color (16 bytes) - position 3: RGBA color
    //   mat4 modelMatrix (64 bytes) - positions 4-7: transform matrix (graphics only)
    vec4 entityData[];
} entities;

// Output: Computed positions (write-only) - not used for random movement
layout(std430, binding = 1) writeonly buffer PositionBuffer {
    vec4 positions[]; // xyz position + w unused
} outPositions;

// Current positions for interpolation (read/write)
layout(std430, binding = 2) buffer CurrentPositionBuffer {
    vec4 currentPositions[]; // xyz current position + w unused
} currentPos;

// Target positions for interpolation (read/write)
layout(std430, binding = 3) buffer TargetPositionBuffer {
    vec4 targetPositions[]; // xyz target position + w unused
} targetPos;

/* ---------- Optimized Random Walk Movement Functions ---------- */

// Constants for improved performance
const float TWO_PI = 6.28318530718;
const uint CYCLE_LENGTH = 900u; // Balanced cycle length for active but smooth movement (15 seconds at 60fps)
const float INV_4294967295 = 2.3283064e-10; // 1.0 / 4294967295.0

// Optimized Wang hash - fewer operations
uint fastHash(uint seed) {
    seed ^= seed >> 16u;
    seed *= 0x7feb352du;
    seed ^= seed >> 15u;
    seed *= 0x846ca68bu;
    seed ^= seed >> 16u;
    return seed;
}

// Fast hash to float conversion
float hashToFloat(uint hash) {
    return float(hash) * INV_4294967295;
}

// Pre-computed sine/cosine lookup tables (shared memory)
shared float sinLookup[64];
shared float cosLookup[64];

// Fast trigonometric approximation using lookup table
void initTrigTables() {
    uint tid = gl_LocalInvocationID.x;
    float angle = float(tid) * (TWO_PI / 64.0);
    sinLookup[tid] = sin(angle);
    cosLookup[tid] = cos(angle);
}

vec2 fastSinCos(float angle) {
    // Normalize angle to [0, TWO_PI]
    angle = mod(angle, TWO_PI);
    
    // Map to lookup table index
    float indexFloat = angle * (64.0 / TWO_PI);
    uint index0 = uint(indexFloat) & 63u;
    uint index1 = (index0 + 1u) & 63u;
    
    // Linear interpolation
    float t = fract(indexFloat);
    float sinVal = mix(sinLookup[index0], sinLookup[index1], t);
    float cosVal = mix(cosLookup[index0], cosLookup[index1], t);
    
    return vec2(sinVal, cosVal);
}

void main() {
    // Initialize shared trigonometric lookup tables once per workgroup
    initTrigTables();
    barrier(); // Wait for lookup table initialization
    
    // Get current entity index with chunk offset
    uint entityIndex = gl_GlobalInvocationID.x + pc.entityOffset;
    
    // Early exit for out-of-bounds entities
    if (entityIndex >= pc.entityCount) {
        return;
    }
    
    // Calculate base offset for this entity (8 vec4s per entity = 128 bytes)
    uint baseOffset = entityIndex * 8u;
    
    // Batch load entity data for better memory access patterns
    vec4 movementParams0 = entities.entityData[baseOffset];
    vec4 movementParams1 = entities.entityData[baseOffset + 1u];
    vec4 runtimeState = entities.entityData[baseOffset + 2u];
    
    // Extract movement parameters
    float amplitude = movementParams0.x;
    float frequency = movementParams0.y;
    float phase = movementParams0.z;
    vec3 center = movementParams1.xyz;
    float initialized = runtimeState.y;
    
    // Calculate cycle using frame number and entity offset for staggering
    float cycle = mod(float(pc.frame + entityIndex * 37u), float(CYCLE_LENGTH));
    
    // Load current position and target (safe initialization)
    vec3 currentPosition;
    vec3 target;
    
    // Initialize buffers for new entities - NO initial dispersal
    if (initialized < 0.5) {
        currentPosition = center;
        target = center; // Start exactly at spawn position - no initial movement
        
        currentPos.currentPositions[entityIndex] = vec4(currentPosition, 1.0);
        targetPos.targetPositions[entityIndex] = vec4(target, 1.0);
        entities.entityData[baseOffset + 2u].y = 1.0; // Mark as initialized
    } else {
        // Load from buffers only if already initialized
        currentPosition = currentPos.currentPositions[entityIndex].xyz;
        target = targetPos.targetPositions[entityIndex].xyz;
    }
    
    // Generate new target on cycle reset
    if (cycle < 1.0) {
        // CRITICAL FIX: At cycle start, current position must be where we actually ended up
        // This prevents entities from "respawning" at incorrect positions
        currentPosition = target;  // We reached the target at the end of the previous cycle
        currentPos.currentPositions[entityIndex] = vec4(currentPosition, 1.0);
        
        // Optimized random generation with fewer hash operations
        uint cycleNumber = pc.frame / CYCLE_LENGTH;
        uint seed = entityIndex ^ (cycleNumber << 16u) ^ uint(phase * 1000.0);
        
        // Single hash call for angle and magnitude
        uint hash1 = fastHash(seed);
        uint hash2 = fastHash(seed ^ 0xAAAAAAAAu);
        
        float randAngle = hashToFloat(hash1) * TWO_PI;
        float stepMagnitude = hashToFloat(hash2) * amplitude;
        
        // Entity drift characteristic (computed once per cycle)
        float driftiness = hashToFloat(fastHash(entityIndex ^ 0x12345678u));
        stepMagnitude *= (2.0 + driftiness * 4.0); // More active steps: 2-6x amplitude for dynamic movement
        
        // Fast trigonometric calculation using lookup table
        vec2 sinCos = fastSinCos(randAngle);
        vec3 randomStep = vec3(
            stepMagnitude * sinCos.y, // cosine
            stepMagnitude * sinCos.x, // sine
            0.0
        );
        
        // Generate new target from the corrected current position
        target = currentPosition + randomStep;
        targetPos.targetPositions[entityIndex] = vec4(target, 1.0);
    }
    
    // Optimized interpolation with pre-computed t
    float t = cycle * (1.0 / float(CYCLE_LENGTH));
    t = t * t * (3.0 - 2.0 * t); // Fast smoothstep approximation
    vec3 interpolatedPosition = mix(currentPosition, target, t);
    
    // Single output write
    outPositions.positions[entityIndex] = vec4(interpolatedPosition, 1.0);
}