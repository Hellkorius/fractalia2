#version 450

// Optimized workgroup size for maximum GPU occupancy
layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

// Push constants for timing and control
layout(push_constant) uniform ComputePushConstants {
    float time;
    float deltaTime;
    uint entityCount;
    uint frame;
    uint entityOffset;  // For chunked dispatches
} pc;

// Input: GPUEntity buffer (read/write for velocity updates)
layout(std430, binding = 0) buffer GPUEntityBuffer {
    // Cache-optimized GPUEntity structure (128 bytes each):
    // C++ struct layout matches this comment:
    //   vec4 velocity (16 bytes) - position 0: velocity.xy, damping, reserved
    //   vec4 movementParams (16 bytes) - position 1: amplitude, frequency, phase, timeOffset
    //   vec4 runtimeState (16 bytes) - position 2: totalTime, initialized, stateTimer, entityState
    //   vec4 color (16 bytes) - position 3: RGBA color
    //   mat4 modelMatrix (64 bytes) - positions 4-7: transform matrix (graphics only)
    vec4 entityData[];
} entities;

// Position buffers are not used by movement shader - only physics shader uses them
// This shader only updates velocity every 900 frames

/* ---------- Optimized Random Walk Movement Functions ---------- */

// Constants for improved performance
const float TWO_PI = 6.28318530718;
const uint CYCLE_LENGTH = 900u; // Balanced cycle length for active but smooth movement (15 seconds at 60fps)
const float INV_4294967295 = 2.3283064e-10; // 1.0 / 4294967295.0

// Optimized Wang hash - fewer operations
uint fastHash(uint seed) {
    seed ^= seed >> 16u;
    seed *= 0x7feb352du;
    seed ^= seed >> 15u;
    seed *= 0x846ca68bu;
    seed ^= seed >> 16u;
    return seed;
}

// Fast hash to float conversion
float hashToFloat(uint hash) {
    return float(hash) * INV_4294967295;
}

// Pre-computed sine/cosine lookup tables (shared memory)
shared float sinLookup[64];
shared float cosLookup[64];

// Fast trigonometric approximation using lookup table
void initTrigTables() {
    uint tid = gl_LocalInvocationID.x;
    float angle = float(tid) * (TWO_PI / 64.0);
    sinLookup[tid] = sin(angle);
    cosLookup[tid] = cos(angle);
}

vec2 fastSinCos(float angle) {
    // Normalize angle to [0, TWO_PI]
    angle = mod(angle, TWO_PI);
    
    // Map to lookup table index
    float indexFloat = angle * (64.0 / TWO_PI);
    uint index0 = uint(indexFloat) & 63u;
    uint index1 = (index0 + 1u) & 63u;
    
    // Linear interpolation
    float t = fract(indexFloat);
    float sinVal = mix(sinLookup[index0], sinLookup[index1], t);
    float cosVal = mix(cosLookup[index0], cosLookup[index1], t);
    
    return vec2(sinVal, cosVal);
}

void main() {
    // Initialize shared trigonometric lookup tables once per workgroup
    initTrigTables();
    barrier(); // Wait for lookup table initialization
    
    // Get current entity index with chunk offset
    uint entityIndex = gl_GlobalInvocationID.x + pc.entityOffset;
    
    // Early exit for out-of-bounds entities
    if (entityIndex >= pc.entityCount) {
        return;
    }
    
    // Calculate base offset for this entity (8 vec4s per entity = 128 bytes)
    uint baseOffset = entityIndex * 8u;
    
    // Load entity data for velocity updates
    vec4 velocity = entities.entityData[baseOffset];           // position 0: velocity
    vec4 movementParams = entities.entityData[baseOffset + 1u]; // position 1: movement params
    vec4 runtimeState = entities.entityData[baseOffset + 2u];   // position 2: runtime state
    
    // Extract movement parameters
    float amplitude = movementParams.x;
    float phase = movementParams.z;
    float initialized = runtimeState.y;
    
    // Mark entity as initialized if not already
    if (initialized < 0.5) {
        entities.entityData[baseOffset + 2u].y = 1.0; // Mark as initialized
    }
    
    // Calculate cycle using frame number and entity offset for staggering
    float cycle = mod(float(pc.frame + entityIndex * 37u), float(CYCLE_LENGTH));
    
    // Generate new velocity direction every 900 frames (cycle reset)
    if (cycle < 1.0) {
        // Optimized random generation
        uint cycleNumber = pc.frame / CYCLE_LENGTH;
        uint seed = entityIndex ^ (cycleNumber << 16u) ^ uint(phase * 1000.0);
        
        // Generate random angle and speed
        uint hash1 = fastHash(seed);
        uint hash2 = fastHash(seed ^ 0xAAAAAAAAu);
        
        float randAngle = hashToFloat(hash1) * TWO_PI;
        float speed = hashToFloat(hash2) * amplitude * 0.1; // Scale down for per-frame movement
        
        // Entity drift characteristic (computed once per cycle)
        float driftiness = hashToFloat(fastHash(entityIndex ^ 0x12345678u));
        speed *= (0.5 + driftiness * 1.5); // Variable speed: 0.5-2.0x base speed
        
        // Fast trigonometric calculation using lookup table
        vec2 sinCos = fastSinCos(randAngle);
        
        // Set new velocity (physics shader will use this for position updates)
        velocity.x = speed * sinCos.y; // cosine for x-velocity
        velocity.y = speed * sinCos.x; // sine for y-velocity
        
        // Write updated velocity back to entity buffer
        entities.entityData[baseOffset] = velocity;
    }
}