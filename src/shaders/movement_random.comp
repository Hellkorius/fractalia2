#version 450
#extension GL_EXT_nonuniform_qualifier : require
#extension GL_GOOGLE_include_directive : require

// Include shared entity buffer indices  
#include "entity_buffer_indices.glsl"

// Optimized workgroup size for maximum GPU occupancy
layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

// Push constants for timing and control
layout(push_constant) uniform ComputePushConstants {
    float time;
    float deltaTime;
    uint entityCount;
    uint frame;
    uint entityOffset;  // For chunked dispatches
} pc;

// Vulkan 1.3 descriptor indexing - single array of all entity buffers
layout(std430, binding = 1) buffer EntityBuffers {
    vec4 data[];
} entityBuffers[];

// Position buffers are not used by movement shader - only physics shader uses them
// This shader only updates velocity and rotation every 120 frames

/* ---------- Optimized Random Walk Movement Functions ---------- */

// Constants for improved performance
const float TWO_PI = 6.28318530718;
const uint CYCLE_LENGTH = 120u; // More frequent movement updates for dynamic behavior (2 seconds at 60fps)
const float INV_4294967295 = 2.3283064e-10; // 1.0 / 4294967295.0

// Optimized Wang hash - fewer operations
uint fastHash(uint seed) {
    seed ^= seed >> 16u;
    seed *= 0x7feb352du;
    seed ^= seed >> 15u;
    seed *= 0x846ca68bu;
    seed ^= seed >> 16u;
    return seed;
}

// Fast hash to float conversion
float hashToFloat(uint hash) {
    return float(hash) * INV_4294967295;
}

// Pre-computed sine/cosine lookup tables (shared memory)
shared float sinLookup[64];
shared float cosLookup[64];

// Fast trigonometric approximation using lookup table
void initTrigTables() {
    uint tid = gl_LocalInvocationID.x;
    float angle = float(tid) * (TWO_PI / 64.0);
    sinLookup[tid] = sin(angle);
    cosLookup[tid] = cos(angle);
}

vec2 fastSinCos(float angle) {
    // Normalize angle to [0, TWO_PI]
    angle = mod(angle, TWO_PI);
    
    // Map to lookup table index
    float indexFloat = angle * (64.0 / TWO_PI);
    uint index0 = uint(indexFloat) & 63u;
    uint index1 = (index0 + 1u) & 63u;
    
    // Linear interpolation
    float t = fract(indexFloat);
    float sinVal = mix(sinLookup[index0], sinLookup[index1], t);
    float cosVal = mix(cosLookup[index0], cosLookup[index1], t);
    
    return vec2(sinVal, cosVal);
}

void main() {
    // Initialize shared trigonometric lookup tables once per workgroup
    initTrigTables();
    barrier(); // Wait for lookup table initialization
    
    // Get current entity index with chunk offset
    uint entityIndex = gl_GlobalInvocationID.x + pc.entityOffset;
    
    // Early exit for out-of-bounds entities
    if (entityIndex >= pc.entityCount) {
        return;
    }
    
    // Load entity data from SoA buffers - much better cache locality (3D support)
    vec4 velocity = entityBuffers[VELOCITY_BUFFER].data[entityIndex];
    vec4 movementParams = entityBuffers[MOVEMENT_PARAMS_BUFFER].data[entityIndex];
    vec4 movementCenter = entityBuffers[MOVEMENT_CENTERS_BUFFER].data[entityIndex];
    vec4 runtimeState = entityBuffers[RUNTIME_STATE_BUFFER].data[entityIndex];
    
    // Extract movement parameters
    float amplitude = movementParams.x;
    float phase = movementParams.z;
    float initialized = runtimeState.w; // initialized flag is in .w
    
    // Mark entity as initialized if not already
    if (initialized < 0.5) {
        entityBuffers[RUNTIME_STATE_BUFFER].data[entityIndex].w = 1.0; // Mark as initialized
    }
    
    // Calculate cycle using frame number and entity offset for staggering
    float cycle = mod(float(pc.frame + entityIndex * 37u), float(CYCLE_LENGTH));
    
    // Generate new velocity direction every 120 frames (cycle reset) OR on initialization
    if (cycle < 1.0 || initialized < 0.5) {
        // TRULY RANDOM: Use entity index and frame for random seed
        uint seed = entityIndex * 1664525u + pc.frame * 1013904223u;
        uint hash = fastHash(seed);
        float randAngle = hashToFloat(hash) * TWO_PI;
        
        // Reduced speed for more controlled movement
        uint speedHash = fastHash(seed + 12345u);
        float speedMultiplier = 0.8 + hashToFloat(speedHash) * 1.0; // Range: 0.8 to 1.8
        float speed = 0.8 * speedMultiplier; // Base speed 0.8, final range: 0.64 to 1.44
        
        // Add moderate angular momentum for dynamic movement
        uint spiralHash = fastHash(seed + 67890u);
        float movementAngularVel = (hashToFloat(spiralHash) - 0.5) * 0.15; // -0.075 to +0.075 rad/frame
        
        // Enhanced 3D random movement - full spherical coordinates
        uint angleHash2 = fastHash(seed + 11111u);
        uint angleHash3 = fastHash(seed + 22222u);
        
        // More varied elevation for full 3D movement
        float elevation = (hashToFloat(angleHash2) - 0.5) * 2.0; // Vertical angle: -1.0 to +1.0 radians (wider range)
        
        // Add azimuth variation for more 3D complexity
        float azimuth = hashToFloat(angleHash3) * TWO_PI;
        
        // Use spherical coordinates for full 3D direction with more Z movement
        float cosElev = cos(elevation);
        velocity.x = speed * cosElev * cos(azimuth + movementAngularVel);
        velocity.y = speed * cosElev * sin(azimuth + movementAngularVel);
        velocity.z = speed * sin(elevation) * 1.5; // Enhanced vertical movement component
        velocity.w = 0.001; // Set damping value for proper 3D physics
        
        // Rotation is now handled entirely by physics shader
        
        // Write updated 3D velocity back to SoA buffer
        entityBuffers[VELOCITY_BUFFER].data[entityIndex] = velocity;
    }
}