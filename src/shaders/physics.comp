#version 450

// Optimized workgroup size for maximum GPU occupancy
layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

// Push constants for timing and control
layout(push_constant) uniform PhysicsPushConstants {
    float time;
    float deltaTime;
    uint entityCount;
    uint frame;
    uint entityOffset;  // For chunked dispatches
} pc;

// Unified SoA binding layout (shared with movement shader)
layout(std430, binding = 0) buffer VelocityBuffer {
    vec4 velocities[];  // R/W: velocity.xy, damping, reserved
} velocityBuffer;

layout(std430, binding = 2) buffer RuntimeStateBuffer {
    vec4 runtimeStates[];  // R/W: totalTime, reserved, stateTimer, initialized
} runtimeStateBuffer;

// Physics-specific buffers
layout(std430, binding = 3) buffer PositionBuffer {
    vec4 positions[]; // RW: computed positions for graphics
} outPositions;

layout(std430, binding = 4) buffer CurrentPositionBuffer {
    vec4 currentPositions[]; // R/W: physics integration state
} currentPos;

// Spatial map buffer for collision detection and spatial queries
layout(std430, binding = 7) buffer SpatialMapBuffer {
    uvec2 spatialCells[]; // R/W: spatial hash grid - packed (entityId, nextIndex)
} spatialMap;

/* ---------- Spatial Map Constants and Functions ---------- */

// 3D Spatial grid configuration
const float CELL_SIZE = 2.0;           // Size of each spatial cell (larger for 3D cubes)
const uint GRID_WIDTH = 32;            // Reduced grid dimensions for 3D (32^3 = 32768 cells)
const uint GRID_HEIGHT = 32;
const uint GRID_DEPTH = 32;
const uint SPATIAL_MAP_SIZE = GRID_WIDTH * GRID_HEIGHT * GRID_DEPTH;
const uint NULL_INDEX = 0xFFFFFFFF;    // Null pointer for linked list

// Fast 3D spatial hash function using bit mixing
uint spatialHash(vec3 position) {
    // Convert world position to grid coordinates
    ivec3 gridCoord = ivec3(floor(position / CELL_SIZE));
    
    // Wrap to grid bounds using bitwise AND (requires power-of-2 dimensions)
    uint x = uint(gridCoord.x) & (GRID_WIDTH - 1);
    uint y = uint(gridCoord.y) & (GRID_HEIGHT - 1);
    uint z = uint(gridCoord.z) & (GRID_DEPTH - 1);
    
    // 3D hash: x + y * width + z * width * height
    return x + y * GRID_WIDTH + z * GRID_WIDTH * GRID_HEIGHT;
}

// Update spatial map entry for this entity
void updateSpatialMap(uint entityIndex, vec3 position) {
    uint cellIndex = spatialHash(position);
    
    // Atomic compare-swap loop to safely update the linked list head
    uint expectedHead;
    do {
        expectedHead = spatialMap.spatialCells[cellIndex].x;
    } while (atomicCompSwap(spatialMap.spatialCells[cellIndex].x, expectedHead, entityIndex) != expectedHead);
    
    // Store old head as our next pointer (building linked list)
    spatialMap.spatialCells[cellIndex].y = expectedHead;
}

/* ---------- Collision Detection Constants and Functions ---------- */

// 3D Collision detection configuration
const uint MAX_ENTITIES_PER_CELL = 32;    // Reduced for 3D (more expensive checks)
const float CUBE_RADIUS = 1.8;            // Bounding sphere radius for cube (âˆš3 * cube_half_size)
const float MIN_SEPARATION = 0.3;         // Minimum separation distance for 3D

// Fast entity collection using spatial map (optimized)
uint collectEntitiesInCell(uint cellIndex, out uint entities[MAX_ENTITIES_PER_CELL]) {
    uint count = 0;
    
    // Read head entity from spatial map
    uint headEntity = spatialMap.spatialCells[cellIndex].x;
    if (headEntity != NULL_INDEX && headEntity < pc.entityCount && count < MAX_ENTITIES_PER_CELL) {
        entities[count] = headEntity;
        count++;
        
        // Read next entity (now checking more entities per cell)
        uint nextEntity = spatialMap.spatialCells[cellIndex].y;
        if (nextEntity != NULL_INDEX && nextEntity < pc.entityCount && 
            nextEntity != headEntity && count < MAX_ENTITIES_PER_CELL) {
            entities[count] = nextEntity;
            count++;
        }
        
        // Note: With current spatial map implementation, we can only reliably get 2 entities
        // In a full linked list implementation, we could traverse more here
    }
    
    return count;
}

// 3D Sphere-sphere collision test (simple and efficient for cubes)
bool sphereCollision(vec3 pos1, vec3 pos2, float radius1, float radius2) {
    vec3 diff = pos2 - pos1;
    float distSq = dot(diff, diff);
    float radiusSum = radius1 + radius2;
    return distSq < (radiusSum * radiusSum);
}

// Resolve 3D collision with strong separation force
vec3 resolveCollision(vec3 currentPos, vec3 newPos, vec3 otherPos) {
    vec3 toOther = otherPos - currentPos;
    float distToOther = length(toOther);
    
    // Calculate safe distance (sum of bounding radii + separation)
    float safeDistance = CUBE_RADIUS * 2.0 + MIN_SEPARATION;
    
    if (distToOther < safeDistance) {
        // Force strong separation - push entity away from collision
        vec3 separationDirection = normalize(currentPos - otherPos);
        
        // If entities are exactly on top of each other, use random direction
        if (length(separationDirection) < 0.001) {
            separationDirection = vec3(1.0, 0.0, 0.0); // Default direction
        }
        
        // Position entity at safe distance away from other entity
        vec3 safePos = otherPos + separationDirection * safeDistance;
        return safePos;
    }
    
    return newPos; // No collision resolution needed
}

void main() {
    // Clear spatial cells (each thread clears one cell)
    if (gl_GlobalInvocationID.x < SPATIAL_MAP_SIZE) {
        spatialMap.spatialCells[gl_GlobalInvocationID.x] = uvec2(NULL_INDEX, NULL_INDEX);
    }
    barrier();
    memoryBarrierShared();
    
    // Get current entity index with chunk offset
    uint entityIndex = gl_GlobalInvocationID.x + pc.entityOffset;
    
    // Early exit for out-of-bounds entities
    if (entityIndex >= pc.entityCount) {
        return;
    }
    
    // Load entity data from SoA buffers - better cache locality
    vec4 velocity = velocityBuffer.velocities[entityIndex];
    vec4 runtimeState = runtimeStateBuffer.runtimeStates[entityIndex];
    
    float initialized = runtimeState.w; // initialized flag is in .w
    
    // Extract velocity and damping
    vec3 vel = velocity.xyz;
    float damping = velocity.w;
    
    // SIMPLIFIED: Read position directly from output buffer, integrate velocity
    vec3 currentPosition = outPositions.positions[entityIndex].xyz;
    
    // On first frame, initialize position if it's zero
    if (length(currentPosition) < 0.01) {
        // Use spawn position from entity index (simple grid)
        currentPosition = vec3(
            float(entityIndex % 10) * 0.8 - 4.0,
            float(entityIndex / 10) * 0.8 - 4.0, 
            0.0
        );
    }
    
    // Physics integration: position += velocity * deltaTime (only if velocity is non-zero)
    if (length(vel) > 0.01) {
        // Enhanced physics integration for frequent movement updates
        currentPosition.x += vel.x * pc.deltaTime * 15.0;
        currentPosition.y += vel.y * pc.deltaTime * 15.0;
        currentPosition.z += vel.z * pc.deltaTime * 15.0;
    }
    
    // Moderate damping to balance frequent updates with momentum retention
    vel *= 0.998;
    
    // Write tentative position to current buffer first
    currentPos.currentPositions[entityIndex] = vec4(currentPosition, 1.0);
    
    // Update spatial map with new 3D position
    updateSpatialMap(entityIndex, currentPosition);
    
    // Wait for all threads to update their positions and spatial maps
    barrier();
    memoryBarrierShared();
    
    // 3D Layered collision detection (spatial cell > sphere > cube calculation)
    vec3 resolvedPosition = currentPosition;
    bool hadCollision = false;
    
    // Get our spatial cell
    uint cellIndex = spatialHash(currentPosition);
    
    // Check neighboring cells in 3D space - current cell plus 6 direct neighbors
    const int offsets[7][3] = int[7][3](
        int[3](0, 0, 0),   // Current cell
        int[3](-1, 0, 0),  // Left
        int[3](1, 0, 0),   // Right
        int[3](0, -1, 0),  // Front
        int[3](0, 1, 0),   // Back
        int[3](0, 0, -1),  // Down
        int[3](0, 0, 1)    // Up
    );
    
    for (int cellIdx = 0; cellIdx < 7 && !hadCollision; cellIdx++) {
        int dx = offsets[cellIdx][0];
        int dy = offsets[cellIdx][1];
        int dz = offsets[cellIdx][2];
        
        // Calculate 3D neighbor cell coordinates
        uint cellX = (cellIndex % GRID_WIDTH);
        uint cellY = (cellIndex / GRID_WIDTH) % GRID_HEIGHT;
        uint cellZ = cellIndex / (GRID_WIDTH * GRID_HEIGHT);
        
        int newX = int(cellX) + dx;
        int newY = int(cellY) + dy;
        int newZ = int(cellZ) + dz;
        
        // Wrap around grid boundaries
        newX = ((newX % int(GRID_WIDTH)) + int(GRID_WIDTH)) % int(GRID_WIDTH);
        newY = ((newY % int(GRID_HEIGHT)) + int(GRID_HEIGHT)) % int(GRID_HEIGHT);
        newZ = ((newZ % int(GRID_DEPTH)) + int(GRID_DEPTH)) % int(GRID_DEPTH);
        
        uint neighborCell = uint(newX + newY * int(GRID_WIDTH) + newZ * int(GRID_WIDTH) * int(GRID_HEIGHT));
        
        // LAYER 1: Spatial cell - collect entities in this neighboring cell
        uint entitiesInCell[MAX_ENTITIES_PER_CELL];
        uint entityCount = collectEntitiesInCell(neighborCell, entitiesInCell);
        
        // Check collision with entities in this cell
        for (uint i = 0; i < entityCount && !hadCollision; i++) {
            uint otherEntityIndex = entitiesInCell[i];
            if (otherEntityIndex == entityIndex) continue; // Skip self
            if (otherEntityIndex >= pc.entityCount) continue;
            
            // Get other entity's position
            vec3 otherPos = currentPos.currentPositions[otherEntityIndex].xyz;
            
            // LAYER 2: Sphere collision test (fast - bounding sphere around cubes)
            if (sphereCollision(currentPosition, otherPos, CUBE_RADIUS, CUBE_RADIUS)) {
                // LAYER 3: Expensive cube calculation - precise collision resolution
                resolvedPosition = resolveCollision(currentPosition, currentPosition, otherPos);
                
                // If position was changed, we had a collision
                if (length(resolvedPosition - currentPosition) > 0.001) {
                    // Stop movement on collision and apply strong separation
                    vel = vec3(0.0, 0.0, 0.0);
                    hadCollision = true;
                }
            }
        }
    }
    
    // Write back final velocity and resolved position
    velocityBuffer.velocities[entityIndex].xyz = vel;
    outPositions.positions[entityIndex] = vec4(resolvedPosition, 1.0);
}