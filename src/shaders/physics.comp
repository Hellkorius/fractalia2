#version 450

// Optimized workgroup size for maximum GPU occupancy
layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

// Push constants for timing and control
layout(push_constant) uniform PhysicsPushConstants {
    float time;
    float deltaTime;
    uint entityCount;
    uint frame;
    uint entityOffset;  // For chunked dispatches
} pc;

// Unified SoA binding layout (shared with movement shader)
layout(std430, binding = 0) buffer VelocityBuffer {
    vec4 velocities[];  // R/W: velocity.xy, damping, reserved
} velocityBuffer;

layout(std430, binding = 2) buffer RuntimeStateBuffer {
    vec4 runtimeStates[];  // R/W: totalTime, reserved, stateTimer, initialized
} runtimeStateBuffer;

// Physics-specific buffers
layout(std430, binding = 3) buffer PositionBuffer {
    vec4 positions[]; // RW: computed positions for graphics
} outPositions;

layout(std430, binding = 4) buffer CurrentPositionBuffer {
    vec4 currentPositions[]; // R/W: physics integration state
} currentPos;

// Spatial map buffer for collision detection and spatial queries
layout(std430, binding = 7) buffer SpatialMapBuffer {
    uvec2 spatialCells[]; // R/W: spatial hash grid - packed (entityId, nextIndex)
} spatialMap;

/* ---------- Spatial Map Constants and Functions ---------- */

// Spatial grid configuration
const float CELL_SIZE = 1.5;           // Size of each spatial cell
const uint GRID_WIDTH = 64;            // Grid dimensions (must be power of 2)
const uint GRID_HEIGHT = 64;
const uint SPATIAL_MAP_SIZE = GRID_WIDTH * GRID_HEIGHT; // 4096 cells
const uint NULL_INDEX = 0xFFFFFFFF;    // Null pointer for linked list

// Fast spatial hash function using bit mixing
uint spatialHash(vec2 position) {
    // Convert world position to grid coordinates
    ivec2 gridCoord = ivec2(floor(position / CELL_SIZE));
    
    // Wrap to grid bounds using bitwise AND (requires power-of-2 dimensions)
    uint x = uint(gridCoord.x) & (GRID_WIDTH - 1);
    uint y = uint(gridCoord.y) & (GRID_HEIGHT - 1);
    
    // Simple hash: x + y * width
    return x + y * GRID_WIDTH;
}

// Update spatial map entry for this entity
void updateSpatialMap(uint entityIndex, vec2 position) {
    uint cellIndex = spatialHash(position);
    
    // Atomic compare-swap loop to safely update the linked list head
    uint expectedHead;
    do {
        expectedHead = spatialMap.spatialCells[cellIndex].x;
    } while (atomicCompSwap(spatialMap.spatialCells[cellIndex].x, expectedHead, entityIndex) != expectedHead);
    
    // Store old head as our next pointer (building linked list)
    spatialMap.spatialCells[cellIndex].y = expectedHead;
}

/* ---------- Collision Detection Constants and Functions ---------- */

// Collision detection configuration
const uint MAX_ENTITIES_PER_CELL = 64;    // Maximum entities to check per cell (much higher)
const float TRIANGLE_RADIUS = 1.5;        // Bounding circle radius for triangle (larger)
const float MIN_SEPARATION = 0.2;         // Minimum separation distance (larger)

// Triangle vertices relative to entity center
const vec2 TRIANGLE_VERTICES[3] = vec2[](
    vec2(0.0, 0.5),      // Top vertex
    vec2(-0.4, -0.25),   // Bottom left
    vec2(0.4, -0.25)     // Bottom right
);

// Fast entity collection using spatial map (optimized)
uint collectEntitiesInCell(uint cellIndex, out uint entities[MAX_ENTITIES_PER_CELL]) {
    uint count = 0;
    
    // Read head entity from spatial map
    uint headEntity = spatialMap.spatialCells[cellIndex].x;
    if (headEntity != NULL_INDEX && headEntity < pc.entityCount && count < MAX_ENTITIES_PER_CELL) {
        entities[count] = headEntity;
        count++;
        
        // Read next entity (now checking more entities per cell)
        uint nextEntity = spatialMap.spatialCells[cellIndex].y;
        if (nextEntity != NULL_INDEX && nextEntity < pc.entityCount && 
            nextEntity != headEntity && count < MAX_ENTITIES_PER_CELL) {
            entities[count] = nextEntity;
            count++;
        }
        
        // Note: With current spatial map implementation, we can only reliably get 2 entities
        // In a full linked list implementation, we could traverse more here
    }
    
    return count;
}

// Circle-circle collision test for quick culling
bool circleCollision(vec2 pos1, vec2 pos2, float radius1, float radius2) {
    float distSq = dot(pos2 - pos1, pos2 - pos1);
    float radiusSum = radius1 + radius2;
    return distSq < (radiusSum * radiusSum);
}

// Point-in-triangle test using barycentric coordinates
bool pointInTriangle(vec2 p, vec2 a, vec2 b, vec2 c) {
    vec2 v0 = c - a;
    vec2 v1 = b - a;
    vec2 v2 = p - a;
    
    float dot00 = dot(v0, v0);
    float dot01 = dot(v0, v1);
    float dot02 = dot(v0, v2);
    float dot11 = dot(v1, v1);
    float dot12 = dot(v1, v2);
    
    float invDenom = 1.0 / (dot00 * dot11 - dot01 * dot01);
    float u = (dot11 * dot02 - dot01 * dot12) * invDenom;
    float v = (dot00 * dot12 - dot01 * dot02) * invDenom;
    
    return (u >= 0.0) && (v >= 0.0) && (u + v <= 1.0);
}

// Triangle-triangle intersection test
bool triangleTriangleCollision(vec2 pos1, vec2 pos2) {
    // Get triangle vertices in world space
    vec2 tri1[3];
    vec2 tri2[3];
    
    for (int i = 0; i < 3; i++) {
        tri1[i] = pos1 + TRIANGLE_VERTICES[i];
        tri2[i] = pos2 + TRIANGLE_VERTICES[i];
    }
    
    // Check if any vertex of tri1 is inside tri2
    for (int i = 0; i < 3; i++) {
        if (pointInTriangle(tri1[i], tri2[0], tri2[1], tri2[2])) {
            return true;
        }
    }
    
    // Check if any vertex of tri2 is inside tri1
    for (int i = 0; i < 3; i++) {
        if (pointInTriangle(tri2[i], tri1[0], tri1[1], tri1[2])) {
            return true;
        }
    }
    
    return false;
}

// Resolve collision with strong separation force
vec2 resolveCollision(vec2 currentPos, vec2 newPos, vec2 otherPos) {
    vec2 toOther = otherPos - currentPos;
    float distToOther = length(toOther);
    
    // Calculate safe distance (sum of bounding radii + separation)
    float safeDistance = TRIANGLE_RADIUS * 2.0 + MIN_SEPARATION;
    
    if (distToOther < safeDistance) {
        // Force strong separation - push entity away from collision
        vec2 separationDirection = normalize(currentPos - otherPos);
        
        // If entities are exactly on top of each other, use random direction
        if (length(separationDirection) < 0.001) {
            separationDirection = vec2(1.0, 0.0); // Default direction
        }
        
        // Position entity at safe distance away from other entity
        vec2 safePos = otherPos + separationDirection * safeDistance;
        return safePos;
    }
    
    return newPos; // No collision resolution needed
}

void main() {
    // Clear spatial cells (each thread clears one cell)
    if (gl_GlobalInvocationID.x < SPATIAL_MAP_SIZE) {
        spatialMap.spatialCells[gl_GlobalInvocationID.x] = uvec2(NULL_INDEX, NULL_INDEX);
    }
    barrier();
    memoryBarrierShared();
    
    // Get current entity index with chunk offset
    uint entityIndex = gl_GlobalInvocationID.x + pc.entityOffset;
    
    // Early exit for out-of-bounds entities
    if (entityIndex >= pc.entityCount) {
        return;
    }
    
    // Load entity data from SoA buffers - better cache locality
    vec4 velocity = velocityBuffer.velocities[entityIndex];
    vec4 runtimeState = runtimeStateBuffer.runtimeStates[entityIndex];
    
    float initialized = runtimeState.w; // initialized flag is in .w
    
    // Extract velocity and damping
    vec2 vel = velocity.xy;
    float damping = velocity.z;
    
    // SIMPLIFIED: Read position directly from output buffer, integrate velocity
    vec3 currentPosition = outPositions.positions[entityIndex].xyz;
    
    // On first frame, initialize position if it's zero
    if (length(currentPosition) < 0.01) {
        // Use spawn position from entity index (simple grid)
        currentPosition = vec3(
            float(entityIndex % 10) * 0.8 - 4.0,
            float(entityIndex / 10) * 0.8 - 4.0, 
            0.0
        );
    }
    
    // Physics integration: position += velocity * deltaTime (only if velocity is non-zero)
    if (length(vel) > 0.01) {
        // Enhanced physics integration for frequent movement updates
        currentPosition.x += vel.x * pc.deltaTime * 15.0;
        currentPosition.y += vel.y * pc.deltaTime * 15.0;
    }
    
    // Moderate damping to balance frequent updates with momentum retention
    vel *= 0.998;
    
    // Write tentative position to current buffer first
    currentPos.currentPositions[entityIndex] = vec4(currentPosition, 1.0);
    
    // Update spatial map with new position
    updateSpatialMap(entityIndex, currentPosition.xy);
    
    // Wait for all threads to update their positions and spatial maps
    barrier();
    memoryBarrierShared();
    
    // Spatial hash collision detection - much faster than O(NÂ²)
    vec2 resolvedPosition = currentPosition.xy;
    bool hadCollision = false;
    
    // Pre-calculate collision parameters
    const float collisionRadius = TRIANGLE_RADIUS * 2.0;
    const float collisionRadiusSq = collisionRadius * collisionRadius;
    
    // Get our spatial cell
    uint cellIndex = spatialHash(currentPosition.xy);
    
    // Check all 8 neighboring cells plus current cell (3x3 grid)
    const int offsets[9][2] = int[9][2](
        int[2](0, 0),   // Current cell
        int[2](-1, 0),  // Left
        int[2](1, 0),   // Right  
        int[2](0, -1),  // Up
        int[2](0, 1),   // Down
        int[2](-1, -1), // Top-left diagonal
        int[2](1, -1),  // Top-right diagonal
        int[2](-1, 1),  // Bottom-left diagonal
        int[2](1, 1)    // Bottom-right diagonal
    );
    
    for (int cellIdx = 0; cellIdx < 9; cellIdx++) {
        int dx = offsets[cellIdx][0];
        int dy = offsets[cellIdx][1];
        
        // Calculate neighbor cell coordinates
        int cellX = int(cellIndex % GRID_WIDTH) + dx;
        int cellY = int(cellIndex / GRID_WIDTH) + dy;
        
        // Wrap around grid boundaries
        cellX = ((cellX % int(GRID_WIDTH)) + int(GRID_WIDTH)) % int(GRID_WIDTH);
        cellY = ((cellY % int(GRID_HEIGHT)) + int(GRID_HEIGHT)) % int(GRID_HEIGHT);
        uint neighborCell = uint(cellX + cellY * int(GRID_WIDTH));
        
        // Collect entities in this neighboring cell
        uint entitiesInCell[MAX_ENTITIES_PER_CELL];
        uint entityCount = collectEntitiesInCell(neighborCell, entitiesInCell);
        
        // Check collision with entities in this cell
        for (uint i = 0; i < entityCount; i++) {
            uint otherEntityIndex = entitiesInCell[i];
            if (otherEntityIndex == entityIndex) continue; // Skip self
            if (otherEntityIndex >= pc.entityCount) continue;
            
            // Get other entity's position
            vec3 otherPos = currentPos.currentPositions[otherEntityIndex].xyz;
            
            // Fast squared distance check (no expensive sqrt)
            vec2 diff = currentPosition.xy - otherPos.xy;
            float distSq = dot(diff, diff);
            
            if (distSq < collisionRadiusSq && distSq > 0.000001) {
                // Collision detected! Fast separation using diff vector
                float invDist = inversesqrt(distSq); // Fast inverse sqrt
                vec2 separationDir = diff * invDist;
                resolvedPosition = otherPos.xy + separationDir * collisionRadius;
                
                // Stop movement entirely on collision
                vel = vec2(0.0, 0.0);
                hadCollision = true;
                break; // Handle first collision only
            }
        }
        
        if (hadCollision) break; // Exit loop
    }
    
    // Write back final velocity and resolved position
    velocityBuffer.velocities[entityIndex].xy = vel;
    outPositions.positions[entityIndex] = vec4(resolvedPosition, currentPosition.z, 1.0);
}