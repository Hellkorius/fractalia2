#version 450
#extension GL_EXT_nonuniform_qualifier : require

// Shared entity buffer indices for descriptor indexing
const uint VELOCITY_BUFFER = 0u;           
const uint MOVEMENT_PARAMS_BUFFER = 1u;    
const uint RUNTIME_STATE_BUFFER = 2u;      
const uint ROTATION_STATE_BUFFER = 3u;     
const uint COLOR_BUFFER = 4u;              
const uint MODEL_MATRIX_BUFFER = 5u;       
const uint POSITION_OUTPUT_BUFFER = 6u;    
const uint CURRENT_POSITION_BUFFER = 7u;   
const uint SPATIAL_MAP_BUFFER = 8u;

// Optimized workgroup size for maximum GPU occupancy
layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

// Push constants for timing and control
layout(push_constant) uniform PhysicsPushConstants {
    float time;
    float deltaTime;
    uint entityCount;
    uint frame;
    uint entityOffset;  // For chunked dispatches
} pc;

// Vulkan 1.3 descriptor indexing - single array of all entity buffers
layout(std430, binding = 1) buffer EntityBuffers {
    vec4 data[];
} entityBuffers[];

// Special spatial map buffer with atomic support (required for atomic operations)
layout(std430, binding = 2) buffer SpatialMapBuffer {
    uvec2 spatialCells[]; // R/W: spatial hash grid - packed (entityId, nextIndex)
} spatialMap;

/* ---------- Spatial Map Constants and Functions ---------- */

// 3D Spatial grid configuration
const float CELL_SIZE = 1.5;           // Size of each spatial cell
const uint GRID_WIDTH = 32;            // Grid dimensions (reduced for 3D to fit memory)
const uint GRID_HEIGHT = 32;
const uint GRID_DEPTH = 16;            // Z layers
const uint SPATIAL_MAP_SIZE = GRID_WIDTH * GRID_HEIGHT * GRID_DEPTH; // 16384 cells
const uint NULL_INDEX = 0xFFFFFFFF;    // Null pointer for linked list

// Fast 3D spatial hash function using bit mixing
uint spatialHash3D(vec3 position) {
    // Convert world position to grid coordinates
    ivec3 gridCoord = ivec3(floor(position / CELL_SIZE));
    
    // Wrap to grid bounds using bitwise AND (requires power-of-2 dimensions)
    uint x = uint(gridCoord.x) & (GRID_WIDTH - 1);
    uint y = uint(gridCoord.y) & (GRID_HEIGHT - 1);
    uint z = uint(gridCoord.z) & (GRID_DEPTH - 1);
    
    // 3D hash: x + y * width + z * width * height
    return x + y * GRID_WIDTH + z * GRID_WIDTH * GRID_HEIGHT;
}

// Update 3D spatial map entry for this entity
void updateSpatialMap3D(uint entityIndex, vec3 position) {
    uint cellIndex = spatialHash3D(position);
    
    // Bounds check for safety
    if (cellIndex >= SPATIAL_MAP_SIZE) return;
    
    // Atomic compare-swap loop to safely update the linked list head
    uint expectedHead;
    do {
        expectedHead = spatialMap.spatialCells[cellIndex].x;
    } while (atomicCompSwap(spatialMap.spatialCells[cellIndex].x, expectedHead, entityIndex) != expectedHead);
    
    // Store old head as our next pointer (building linked list)
    spatialMap.spatialCells[cellIndex].y = expectedHead;
}

/* ---------- Collision Detection Constants and Functions ---------- */

// 3D Collision detection configuration
const uint MAX_ENTITIES_PER_CELL = 32;    // Reduced for 3D (more cells to check)
const float CUBE_RADIUS = 0.8;            // Bounding sphere radius for cube
const float MIN_SEPARATION = 0.3;         // Minimum separation distance

// Fast entity collection using spatial map (optimized)
uint collectEntitiesInCell(uint cellIndex, out uint entities[MAX_ENTITIES_PER_CELL]) {
    uint count = 0;
    
    // Read head entity from spatial map
    uint headEntity = spatialMap.spatialCells[cellIndex].x;
    if (headEntity != NULL_INDEX && headEntity < pc.entityCount && count < MAX_ENTITIES_PER_CELL) {
        entities[count] = headEntity;
        count++;
        
        // Read next entity (now checking more entities per cell)
        uint nextEntity = spatialMap.spatialCells[cellIndex].y;
        if (nextEntity != NULL_INDEX && nextEntity < pc.entityCount && 
            nextEntity != headEntity && count < MAX_ENTITIES_PER_CELL) {
            entities[count] = nextEntity;
            count++;
        }
        
        // Note: With current spatial map implementation, we can only reliably get 2 entities
        // In a full linked list implementation, we could traverse more here
    }
    
    return count;
}

// 3D Sphere-sphere collision test
bool sphereCollision3D(vec3 pos1, vec3 pos2, float radius1, float radius2) {
    vec3 diff = pos2 - pos1;
    float distSq = dot(diff, diff);
    float radiusSum = radius1 + radius2;
    return distSq < (radiusSum * radiusSum);
}

// Resolve 3D collision with separation force
vec3 resolveCollision3D(vec3 currentPos, vec3 otherPos) {
    vec3 diff = currentPos - otherPos;
    float distSq = dot(diff, diff);
    
    // Calculate safe distance (sum of bounding radii + separation)
    float safeDistance = CUBE_RADIUS * 2.0 + MIN_SEPARATION;
    float safeDistanceSq = safeDistance * safeDistance;
    
    if (distSq < safeDistanceSq && distSq > 0.000001) {
        // Force separation - push entity away from collision
        float invDist = inversesqrt(distSq); // Fast inverse sqrt
        vec3 separationDir = diff * invDist;
        
        // Position entity at safe distance away from other entity
        return otherPos + separationDir * safeDistance;
    }
    
    return currentPos; // No collision resolution needed
}

void main() {
    // Clear spatial cells (each thread clears one cell)
    if (gl_GlobalInvocationID.x < SPATIAL_MAP_SIZE) {
        spatialMap.spatialCells[gl_GlobalInvocationID.x] = uvec2(NULL_INDEX, NULL_INDEX);
    }
    barrier();
    memoryBarrierShared();
    
    // Get current entity index with chunk offset
    uint entityIndex = gl_GlobalInvocationID.x + pc.entityOffset;
    
    // Early exit for out-of-bounds entities
    if (entityIndex >= pc.entityCount) {
        return;
    }
    
    // Load entity data from SoA buffers - better cache locality
    vec4 velocity = entityBuffers[VELOCITY_BUFFER].data[entityIndex];
    vec4 runtimeState = entityBuffers[RUNTIME_STATE_BUFFER].data[entityIndex];
    vec4 rotationState = entityBuffers[ROTATION_STATE_BUFFER].data[entityIndex];
    
    float initialized = runtimeState.w; // initialized flag is in .w
    
    // Extract velocity and damping (now supporting 3D velocity)
    vec3 vel = velocity.xyz;
    float damping = velocity.w;
    
    // SIMPLIFIED: Read position directly from output buffer, integrate velocity
    vec3 currentPosition = entityBuffers[POSITION_OUTPUT_BUFFER].data[entityIndex].xyz;
    
    // On first frame, initialize position if it's zero
    if (length(currentPosition) < 0.01) {
        // Use spawn position from entity index (3D grid with height variation)
        float gridX = float(entityIndex % 100) * 0.8 - 40.0;  // Wider X spread
        float gridY = float((entityIndex / 100) % 100) * 0.8 - 40.0;  // Wider Y spread
        float gridZ = float(entityIndex / 10000) * 2.0 - 10.0;  // Z layers: -10 to +10
        
        // Add randomization to grid positions for more natural distribution
        uint seed = entityIndex * 2654435761u;
        float randX = (float(seed & 0xFFFFu) / 65535.0 - 0.5) * 4.0;
        seed = seed * 1664525u + 1013904223u;
        float randY = (float(seed & 0xFFFFu) / 65535.0 - 0.5) * 4.0;  
        seed = seed * 1664525u + 1013904223u;
        float randZ = (float(seed & 0xFFFFu) / 65535.0 - 0.5) * 8.0;
        
        currentPosition = vec3(gridX + randX, gridY + randY, gridZ + randZ);
    }
    
    // Physics integration: position += velocity * deltaTime (3D movement)
    if (length(vel) > 0.01) {
        // Enhanced physics integration for frequent movement updates (3D)
        currentPosition.x += vel.x * pc.deltaTime * 15.0;
        currentPosition.y += vel.y * pc.deltaTime * 15.0;
        currentPosition.z += vel.z * pc.deltaTime * 15.0;  // Add Z-axis movement
    }
    
    // Moderate damping to balance frequent updates with momentum retention (3D)
    vel *= 0.998;
    
    // Generate individual rotation physics directly in physics shader
    float baseRotation = float(entityIndex % 360) * 0.01745; // Individual base rotation (degrees to radians)
    float timeRotation = sin(pc.time * 0.1 + baseRotation) * 0.5; // Individual oscillation
    rotationState.x = timeRotation;
    
    // Write tentative position to current buffer first
    entityBuffers[CURRENT_POSITION_BUFFER].data[entityIndex] = vec4(currentPosition, 1.0);
    
    // Update 3D spatial map with new position
    updateSpatialMap3D(entityIndex, currentPosition);
    
    // Wait for all threads to update their positions and spatial maps
    barrier();
    memoryBarrierShared();
    
    // 3D Spatial hash collision detection - much faster than O(NÂ²)
    vec3 resolvedPosition = currentPosition;
    bool hadCollision = false;
    
    // Pre-calculate collision parameters
    const float collisionRadius = CUBE_RADIUS * 2.0;
    const float collisionRadiusSq = collisionRadius * collisionRadius;
    
    // Get our spatial cell
    uint cellIndex = spatialHash3D(currentPosition);
    
    // Check all 26 neighboring cells plus current cell (3x3x3 grid)
    const int offsets[27][3] = int[27][3](
        // Current layer (z=0)
        int[3](0, 0, 0),   int[3](-1, 0, 0),  int[3](1, 0, 0),   int[3](0, -1, 0),  int[3](0, 1, 0),
        int[3](-1, -1, 0), int[3](1, -1, 0),  int[3](-1, 1, 0),  int[3](1, 1, 0),
        // Bottom layer (z=-1)
        int[3](0, 0, -1),  int[3](-1, 0, -1), int[3](1, 0, -1),  int[3](0, -1, -1), int[3](0, 1, -1),
        int[3](-1, -1, -1),int[3](1, -1, -1), int[3](-1, 1, -1), int[3](1, 1, -1),
        // Top layer (z=1)
        int[3](0, 0, 1),   int[3](-1, 0, 1),  int[3](1, 0, 1),   int[3](0, -1, 1),  int[3](0, 1, 1),
        int[3](-1, -1, 1), int[3](1, -1, 1),  int[3](-1, 1, 1),  int[3](1, 1, 1)
    );
    
    for (int cellIdx = 0; cellIdx < 27; cellIdx++) {
        int dx = offsets[cellIdx][0];
        int dy = offsets[cellIdx][1];
        int dz = offsets[cellIdx][2];
        
        // Calculate neighbor cell coordinates (3D)
        int cellX = int(cellIndex % GRID_WIDTH) + dx;
        int cellY = int((cellIndex / GRID_WIDTH) % GRID_HEIGHT) + dy;
        int cellZ = int(cellIndex / (GRID_WIDTH * GRID_HEIGHT)) + dz;
        
        // Wrap around grid boundaries
        cellX = ((cellX % int(GRID_WIDTH)) + int(GRID_WIDTH)) % int(GRID_WIDTH);
        cellY = ((cellY % int(GRID_HEIGHT)) + int(GRID_HEIGHT)) % int(GRID_HEIGHT);
        cellZ = ((cellZ % int(GRID_DEPTH)) + int(GRID_DEPTH)) % int(GRID_DEPTH);
        uint neighborCell = uint(cellX + cellY * int(GRID_WIDTH) + cellZ * int(GRID_WIDTH) * int(GRID_HEIGHT));
        
        // Collect entities in this neighboring cell
        uint entitiesInCell[MAX_ENTITIES_PER_CELL];
        uint entityCount = collectEntitiesInCell(neighborCell, entitiesInCell);
        
        // Check collision with entities in this cell
        for (uint i = 0; i < entityCount; i++) {
            uint otherEntityIndex = entitiesInCell[i];
            if (otherEntityIndex == entityIndex) continue; // Skip self
            if (otherEntityIndex >= pc.entityCount) continue;
            
            // Get other entity's position
            vec3 otherPos = entityBuffers[CURRENT_POSITION_BUFFER].data[otherEntityIndex].xyz;
            
            // 3D distance check for collision detection
            vec3 diff = currentPosition - otherPos;
            float distSq = dot(diff, diff);
            
            if (distSq < collisionRadiusSq && distSq > 0.000001) {
                // 3D Collision detected! Resolve using 3D separation
                resolvedPosition = resolveCollision3D(currentPosition, otherPos);
                
                // Dampen velocity on collision (3D)
                vel *= 0.3; // Reduce velocity significantly on collision
                hadCollision = true;
                break; // Handle first collision only
            }
        }
        
        if (hadCollision) break; // Exit loop
    }
    
    // Write back final velocity, rotation state, and full 3D position
    entityBuffers[VELOCITY_BUFFER].data[entityIndex] = vec4(vel, damping);
    entityBuffers[ROTATION_STATE_BUFFER].data[entityIndex] = rotationState;
    entityBuffers[POSITION_OUTPUT_BUFFER].data[entityIndex] = vec4(resolvedPosition, 0.0);
}