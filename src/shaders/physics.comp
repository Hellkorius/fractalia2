#version 450

// Optimized workgroup size for maximum GPU occupancy
layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

// Push constants for timing and control
layout(push_constant) uniform PhysicsPushConstants {
    float time;
    float deltaTime;
    uint entityCount;
    uint frame;
    uint entityOffset;  // For chunked dispatches
} pc;

// Unified SoA binding layout (shared with movement shader)
layout(std430, binding = 0) buffer VelocityBuffer {
    vec4 velocities[];  // R/W: velocity.xy, damping, reserved
} velocityBuffer;

layout(std430, binding = 2) buffer RuntimeStateBuffer {
    vec4 runtimeStates[];  // R/W: totalTime, reserved, stateTimer, initialized
} runtimeStateBuffer;

// Physics-specific buffers
layout(std430, binding = 3) buffer PositionBuffer {
    vec4 positions[]; // RW: computed positions for graphics
} outPositions;

layout(std430, binding = 4) buffer CurrentPositionBuffer {
    vec4 currentPositions[]; // R/W: physics integration state
} currentPos;

void main() {
    // Get current entity index with chunk offset
    uint entityIndex = gl_GlobalInvocationID.x + pc.entityOffset;
    
    // Early exit for out-of-bounds entities
    if (entityIndex >= pc.entityCount) {
        return;
    }
    
    // Load entity data from SoA buffers - better cache locality
    vec4 velocity = velocityBuffer.velocities[entityIndex];
    vec4 runtimeState = runtimeStateBuffer.runtimeStates[entityIndex];
    
    float initialized = runtimeState.w; // initialized flag is in .w
    
    // Extract velocity and damping
    vec2 vel = velocity.xy;
    float damping = velocity.z;
    
    // SIMPLIFIED: Read position directly from output buffer, integrate velocity
    vec3 currentPosition = outPositions.positions[entityIndex].xyz;
    
    // On first frame, initialize position if it's zero
    if (length(currentPosition) < 0.01) {
        // Use spawn position from entity index (simple grid)
        currentPosition = vec3(
            float(entityIndex % 10) * 0.8 - 4.0,
            float(entityIndex / 10) * 0.8 - 4.0, 
            0.0
        );
    }
    
    // Physics integration: position += velocity * deltaTime (only if velocity is non-zero)
    if (length(vel) > 0.01) {
        currentPosition.x += vel.x * pc.deltaTime * 10.0;
        currentPosition.y += vel.y * pc.deltaTime * 10.0;
    }
    
    // Apply very light damping to velocity (much less damping)
    vel *= 0.999;
    
    // Write back velocity and position
    velocityBuffer.velocities[entityIndex].xy = vel;
    outPositions.positions[entityIndex] = vec4(currentPosition, 1.0);
}