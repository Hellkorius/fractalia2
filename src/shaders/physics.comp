#version 450
#extension GL_EXT_nonuniform_qualifier : require
#extension GL_GOOGLE_include_directive : require

// Include shared entity buffer indices
#include "entity_buffer_indices.glsl"

// Optimized workgroup size for maximum GPU occupancy
layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

// Push constants for timing and control (matching NodePushConstants from CPU)
layout(push_constant) uniform NodePushConstants {
    float time;
    float deltaTime;
    uint entityCount;
    uint frame;
    uint param1;            // entityOffset for chunked dispatches
    uint param2;            // Future expansion
    float gravityStrength;  // Gravity acceleration (e.g., 9.81)
    float restitution;      // Bounce factor (0.0-1.0)
    float friction;         // Surface friction (0.0-1.0)
    uint padding;           // Alignment padding
} pc;

// Vulkan 1.3 descriptor indexing - single array of all entity buffers
layout(std430, binding = 1) buffer EntityBuffers {
    vec4 data[];
} entityBuffers[];

// Spatial buffers use dedicated bindings with proper types for atomic operations
layout(std430, binding = 2) buffer SpatialMapBuffer {
    uvec2 cellMetadata[];     // [entityCount, entityOffset] per cell
} spatialMap;

layout(std430, binding = 10) buffer SpatialEntitiesBuffer {
    uint entityIndices[];     // Flat array: [cell0_entities...][cell1_entities...]...
} spatialEntities;

/* ---------- Spatial Map Constants and Functions ---------- */

// FIRST-PRINCIPLES SPATIAL HASH: Properly sized for collision detection
const float ENTITY_RADIUS = 0.5;       // Conservative entity radius for collision
const float CELL_SIZE = 3.0;           // 6x entity radius = guaranteed single-cell containment
const uint GRID_WIDTH = 32;            // Reduced grid for better cache locality
const uint GRID_HEIGHT = 32;           // 32x32x16 = 16,384 cells total
const uint GRID_DEPTH = 16;            // Increased depth for better 3D distribution
const uint SPATIAL_MAP_SIZE = GRID_WIDTH * GRID_HEIGHT * GRID_DEPTH; // 16384 cells
const uint MAX_ENTITIES_PER_CELL = 16;  // Reduced for better performance

// Clean spatial buffer access using proper types - no workarounds needed

// Initialize spatial map buffer offsets (called once per frame) 
void initializeSpatialMap() {
    uint globalIndex = gl_GlobalInvocationID.x;
    
    // Parallel initialization: each thread clears one cell
    if (globalIndex < SPATIAL_MAP_SIZE) {
        spatialMap.cellMetadata[globalIndex].x = 0; // entityCount = 0
        // entityOffset is set once during CPU buffer setup and doesn't change
    }
    
    // Ensure all threads wait for initialization
    barrier();
    memoryBarrierBuffer();
}

// Cache-friendly 3D access pattern constants  
const uint Z_STRIDE = GRID_WIDTH * GRID_HEIGHT;  // 1024 - one cache line per Z level
const uint Y_STRIDE = GRID_WIDTH;                // 32 - fits in cache line

// FIRST-PRINCIPLES COLLISION: Conservative and deterministic
const float COLLISION_RADIUS = ENTITY_RADIUS * 2.2; // 1.1 = slight overlap tolerance
const float MIN_SEPARATION = 0.1;                   // Small separation buffer

// Cache-optimized 3D spatial hash function
uint spatialHash3D(vec3 position) {
    // Convert world position to grid coordinates
    ivec3 gridCoord = ivec3(floor(position / CELL_SIZE));
    
    // Wrap to grid bounds using bitwise AND (requires power-of-2 dimensions)
    uint x = uint(gridCoord.x) & (GRID_WIDTH - 1);
    uint y = uint(gridCoord.y) & (GRID_HEIGHT - 1);
    uint z = uint(gridCoord.z) & (GRID_DEPTH - 1);
    
    // Cache-friendly layout: Z-order curve for spatial locality  
    // Interleave bits: Z layers grouped for cache coherency
    return x + (y << 5) + (z << 10);  // x + y*32 + z*1024
}

// Calculate entity bounds from model matrix
struct EntityBounds {
    vec3 minBounds;
    vec3 maxBounds;
};

EntityBounds calculateEntityBounds(uint entityIndex, vec3 position) {
    // Fixed entity size for consistent collision detection
    vec3 radius = vec3(ENTITY_RADIUS, ENTITY_RADIUS, ENTITY_RADIUS);
    
    EntityBounds bounds;
    bounds.minBounds = position - radius;
    bounds.maxBounds = position + radius;
    return bounds;
}

/* ---------- Entity Type Constants ---------- */

// Entity type definitions (must match CPU EntityType enum)  
const float ENTITY_TYPE_REGULAR = 0.0;
const float ENTITY_TYPE_FLOOR = 1.0;

// Helper function to check entity type from runtime state
bool isFloorEntity(uint entityIndex) {
    vec4 runtimeState = entityBuffers[RUNTIME_STATE_BUFFER].data[entityIndex];
    return abs(runtimeState.y - ENTITY_TYPE_FLOOR) < 0.1; // .y contains entityType
}

// Bespoke floor entity spatial occupancy - ensures massive floor coverage
void insertFloorEntityIntoCells(uint entityIndex, vec3 position) {
    // Floor entities are MASSIVE (1000×2×1000 units) and need comprehensive spatial coverage
    // For floor at Y=-5 with scale (1000, 2, 1000), we need cells from roughly:
    // X: [-500 to +500] / CELL_SIZE = [-250 to +250] cells  
    // Y: [-6 to -4] / CELL_SIZE = [-3 to -2] cells
    // Z: [-500 to +500] / CELL_SIZE = [-250 to +250] cells
    
    // Calculate floor bounds from model matrix scale
    vec3 col0 = entityBuffers[MODEL_MATRIX_BUFFER].data[entityIndex * 4 + 0].xyz;
    vec3 col1 = entityBuffers[MODEL_MATRIX_BUFFER].data[entityIndex * 4 + 1].xyz;
    vec3 col2 = entityBuffers[MODEL_MATRIX_BUFFER].data[entityIndex * 4 + 2].xyz;
    vec3 scale = vec3(length(col0), length(col1), length(col2));
    vec3 halfSize = scale * 0.5;
    
    vec3 minBounds = position - halfSize;
    vec3 maxBounds = position + halfSize;
    
    // Convert to spatial cell coordinates
    ivec3 minCell = ivec3(floor(minBounds / CELL_SIZE));
    ivec3 maxCell = ivec3(floor(maxBounds / CELL_SIZE));
    
    // Clamp to grid bounds
    minCell = max(minCell, ivec3(0));
    maxCell = min(maxCell, ivec3(int(GRID_WIDTH-1), int(GRID_HEIGHT-1), int(GRID_DEPTH-1)));
    
    // Insert floor into ALL cells it occupies (this will be MANY cells)
    for (int z = minCell.z; z <= maxCell.z; z++) {
        for (int y = minCell.y; y <= maxCell.y; y++) {
            for (int x = minCell.x; x <= maxCell.x; x++) {
                uint cellIndex = uint(x) + (uint(y) << 6) + (uint(z) << 12);
                
                if (cellIndex < SPATIAL_MAP_SIZE) {
                    // ATOMIC RESERVATION for floor entity - proper types, proper atomics
                    uint reservedSlot = atomicAdd(spatialMap.cellMetadata[cellIndex].x, 1);
                    uint entityOffset = spatialMap.cellMetadata[cellIndex].y;
                    
                    // Floor entity gets priority - always try to insert
                    if (reservedSlot < MAX_ENTITIES_PER_CELL) {
                        uint insertIndex = entityOffset + reservedSlot;
                        if (insertIndex < spatialEntities.entityIndices.length()) {
                            spatialEntities.entityIndices[insertIndex] = entityIndex;
                        }
                    } else {
                        // Rollback on overflow - floor is critical so this shouldn't happen
                        atomicAdd(spatialMap.cellMetadata[cellIndex].x, -1);
                    }
                }
            }
        }
    }
}

// SIMPLIFIED ENTITY INSERTION: Single cell per entity with proper sizing
void insertRegularEntityIntoCells(uint entityIndex, vec3 position) {
    if (entityIndex >= pc.entityCount) return;
    
    // Single cell insertion - CELL_SIZE is large enough to contain entire entity
    uint cellIndex = spatialHash3D(position);
    
    if (cellIndex < SPATIAL_MAP_SIZE) {
        // ATOMIC RESERVATION - prevents race condition
        uint reservedSlot = atomicAdd(spatialMap.cellMetadata[cellIndex].x, 1);
        uint entityOffset = spatialMap.cellMetadata[cellIndex].y;
        
        // Safety check with atomic count
        if (reservedSlot < MAX_ENTITIES_PER_CELL) {
            uint insertIndex = entityOffset + reservedSlot;
            if (insertIndex < spatialEntities.entityIndices.length()) {
                spatialEntities.entityIndices[insertIndex] = entityIndex;
            }
        } else {
            // Rollback on overflow
            atomicAdd(spatialMap.cellMetadata[cellIndex].x, -1);
        }
    }
}

// Removed cached floor collision system to prevent conflicts with hardcoded system

// FIRST-PRINCIPLES COLLISION SYSTEM: Simple, deterministic, robust

// Floor collision check - simple AABB vs sphere
bool checkFloorCollision(vec3 position, out vec3 correctedPosition) {
    // Floor parameters - match control_service.cpp exactly
    const vec3 floorCenter = vec3(0.0, -5.0, 0.0);
    const vec3 floorHalfSize = vec3(500.0, 1.0, 500.0); // 1000x2x1000 -> half size
    
    // Entity bottom point
    float entityBottom = position.y - ENTITY_RADIUS;
    float floorTop = floorCenter.y + floorHalfSize.y; // -5 + 1 = -4
    
    // Check if entity is above floor and within horizontal bounds
    bool withinBounds = (position.x >= floorCenter.x - floorHalfSize.x - ENTITY_RADIUS &&
                         position.x <= floorCenter.x + floorHalfSize.x + ENTITY_RADIUS &&
                         position.z >= floorCenter.z - floorHalfSize.z - ENTITY_RADIUS &&
                         position.z <= floorCenter.z + floorHalfSize.z + ENTITY_RADIUS);
    
    if (!withinBounds) {
        correctedPosition = position;
        return false;
    }
    
    // Floor collision: push entity up so bottom is at floor top
    if (entityBottom <= floorTop) {
        correctedPosition = position;
        correctedPosition.y = floorTop + ENTITY_RADIUS; // Entity center at floor + radius
        return true;
    }
    
    correctedPosition = position;
    return false;
}

// Entity-entity collision check - simple sphere vs sphere
bool checkEntityCollision(vec3 position, vec3 otherPosition, out vec3 separation) {
    vec3 diff = position - otherPosition;
    float distSq = dot(diff, diff);
    float collisionDistSq = COLLISION_RADIUS * COLLISION_RADIUS;
    
    if (distSq > 0.000001 && distSq < collisionDistSq) {
        float distance = sqrt(distSq);
        float penetration = COLLISION_RADIUS - distance;
        separation = (diff / distance) * penetration;
        return true;
    }
    
    separation = vec3(0.0);
    return false;
}

// Unified insertion function - all entities go to spatial hash (floor collisions handled separately)
void insertEntityIntoCells(uint entityIndex, vec3 position) {
    if (entityIndex >= pc.entityCount) return;
    
    // ALL entities go into spatial hash for entity-entity collision detection
    // Floor collisions are still handled by the separate checkFloorCollision() function
    if (isFloorEntity(entityIndex)) {
        insertFloorEntityIntoCells(entityIndex, position);
    } else {
        insertRegularEntityIntoCells(entityIndex, position);
    }
}

/* ---------- Collision Detection Constants and Functions ---------- */

// Gold standard bucketed hash table entity collection
uint collectEntitiesInCell(uint cellIndex, out uint entities[MAX_ENTITIES_PER_CELL]) {
    if (cellIndex >= SPATIAL_MAP_SIZE) return 0;
    
    // Get cell metadata directly from proper buffer types
    uvec2 cellData = spatialMap.cellMetadata[cellIndex];
    uint entityCount = min(cellData.x, MAX_ENTITIES_PER_CELL); // Safety clamp
    uint entityOffset = cellData.y;
    
    // Copy entities from flat array to local array
    for (uint i = 0; i < entityCount; i++) {
        uint sourceIndex = entityOffset + i;
        if (sourceIndex < spatialEntities.entityIndices.length()) {
            entities[i] = spatialEntities.entityIndices[sourceIndex];
        } else {
            // Safety: truncate if buffer bounds exceeded
            return i;
        }
    }
    
    return entityCount;
}

// Old collision functions removed - using unified collision system


void main() {
    // Initialize spatial map with bucketed hash table approach
    initializeSpatialMap();
    
    // Get current entity index with chunk offset
    uint entityIndex = gl_GlobalInvocationID.x + pc.param1;
    
    // Early exit for out-of-bounds entities
    if (entityIndex >= pc.entityCount) {
        return;
    }
    
    // Load entity data from SoA buffers - better cache locality
    vec4 velocity = entityBuffers[VELOCITY_BUFFER].data[entityIndex];
    vec4 runtimeState = entityBuffers[RUNTIME_STATE_BUFFER].data[entityIndex];
    vec4 rotationState = entityBuffers[ROTATION_STATE_BUFFER].data[entityIndex];
    
    float initialized = runtimeState.w; // initialized flag is in .w
    float entityType = runtimeState.y;  // entity type in .y
    
    // Extract velocity and damping (now supporting 3D velocity)
    vec3 vel = velocity.xyz;
    float damping = velocity.w;
    
    // NEW MVP APPROACH: Extract position from model matrix (column 3)
    vec3 currentPosition = entityBuffers[MODEL_MATRIX_BUFFER].data[entityIndex * 4 + 3].xyz;
    
    // Skip physics for floor entities (they don't move)
    bool isFloor = abs(entityType - ENTITY_TYPE_FLOOR) < 0.1;
    if (isFloor) {
        // Floor entities are static - but they need position initialization too
        // If floor position is zero, it means it hasn't been initialized yet
        if (length(currentPosition) < 0.01) {
            // Floor entities get their position from their initial setup
            // For now, use a default floor position - this should be set by the CPU
            currentPosition = vec3(0.0, -5.0, 0.0);  // Floor at Y=-5 (gravity pulls down in Y)
        }
        
        // Update spatial map for collision detection
        insertEntityIntoCells(entityIndex, currentPosition);
        return;
    }
    
    // Initialize position if needed
    if (length(currentPosition) < 0.01) {
        // CONTROLLED SPAWN: Tight grid to test collision system
        float gridX = float(entityIndex % 10) * (COLLISION_RADIUS * 0.8); // Slightly overlapping
        float gridZ = float(entityIndex / 10) * (COLLISION_RADIUS * 0.8);
        float gridY = -2.0; // Above floor (floor top is at Y=-4)
        
        currentPosition = vec3(gridX, gridY, gridZ);
        
        // Initialize model matrix position
        entityBuffers[MODEL_MATRIX_BUFFER].data[entityIndex * 4 + 3] = vec4(currentPosition, 1.0);
        
        // Initialize with small random velocity
        uint seed = entityIndex * 2654435761u;
        float randVx = (float(seed & 0xFFFFu) / 65535.0 - 0.5) * 2.0;
        seed = seed * 1664525u + 1013904223u;
        float randVz = (float(seed & 0xFFFFu) / 65535.0 - 0.5) * 2.0;
        vel = vec3(randVx, 0.0, randVz);
    }
    
    // FIRST-PRINCIPLES PHYSICS PIPELINE
    
    // STEP 1: Apply forces (gravity only)
    vel.y -= pc.gravityStrength * pc.deltaTime;
    
    // STEP 2: Calculate desired position from integration
    vec3 desiredPosition = currentPosition + vel * pc.deltaTime;
    
    // STEP 3: Insert current position into spatial hash
    insertEntityIntoCells(entityIndex, currentPosition);
    
    // Synchronize spatial hash population
    barrier();
    memoryBarrierBuffer();
    
    // STEP 4: Collision detection and resolution
    vec3 resolvedPosition = desiredPosition;
    
    // Check floor collision first
    vec3 floorCorrectedPosition;
    bool hitFloor = checkFloorCollision(resolvedPosition, floorCorrectedPosition);
    if (hitFloor) {
        resolvedPosition = floorCorrectedPosition;
        // Stop downward velocity on floor hit
        if (vel.y < 0.0) {
            vel.y = 0.0;
        }
    }
    
    // Check entity-entity collisions
    uint cellIndex = spatialHash3D(currentPosition); // Use current position for spatial lookup
    
    // Check current cell and immediate neighbors (3x3x1 = 9 cells)
    const int offsets[9][2] = int[9][2](
        int[2](-1, -1), int[2](0, -1), int[2](1, -1),
        int[2](-1,  0), int[2](0,  0), int[2](1,  0),
        int[2](-1,  1), int[2](0,  1), int[2](1,  1)
    );
    
    vec3 totalSeparation = vec3(0.0);
    
    for (int cellIdx = 0; cellIdx < 9; cellIdx++) {
        int dx = offsets[cellIdx][0];
        int dz = offsets[cellIdx][1];
        
        // Calculate neighbor cell
        uint currentX = cellIndex & (GRID_WIDTH - 1);
        uint currentY = (cellIndex >> 5) & (GRID_HEIGHT - 1);
        uint currentZ = (cellIndex >> 10) & (GRID_DEPTH - 1);
        
        uint neighborX = (currentX + uint(dx + int(GRID_WIDTH))) & (GRID_WIDTH - 1);
        uint neighborZ = (currentZ + uint(dz + int(GRID_DEPTH))) & (GRID_DEPTH - 1);
        uint neighborCell = neighborX + (currentY << 5) + (neighborZ << 10);
        
        // Collect entities in this cell
        uint entitiesInCell[MAX_ENTITIES_PER_CELL];
        uint entityCount = collectEntitiesInCell(neighborCell, entitiesInCell);
        
        // Check collision with other entities
        for (uint i = 0; i < entityCount; i++) {
            uint otherEntityIndex = entitiesInCell[i];
            if (otherEntityIndex == entityIndex) continue; // Skip self
            if (otherEntityIndex >= pc.entityCount) continue;
            if (isFloorEntity(otherEntityIndex)) continue; // Skip floor entities
            
            // Get other entity's current position from spatial hash
            vec3 otherPosition = entityBuffers[MODEL_MATRIX_BUFFER].data[otherEntityIndex * 4 + 3].xyz;
            
            // Check collision
            vec3 separation;
            if (checkEntityCollision(resolvedPosition, otherPosition, separation)) {
                totalSeparation += separation;
            }
        }
    }
    
    // Apply entity separation
    if (length(totalSeparation) > 0.01) {
        resolvedPosition += totalSeparation;
        
        // Bounce velocity
        vec3 separationDir = normalize(totalSeparation);
        float velocityAlongSeparation = dot(vel, separationDir);
        if (velocityAlongSeparation < 0.0) {
            vel -= separationDir * velocityAlongSeparation * pc.restitution;
        }
    }
    
    // Apply friction and damping
    vel *= (1.0 - pc.friction * pc.deltaTime);
    
    // STEP 5: Finalize position
    currentPosition = resolvedPosition;
    
    // Generate rotation
    float baseRotation = float(entityIndex % 360) * 0.01745;
    float timeRotation = sin(pc.time * 0.1 + baseRotation) * 0.5;
    rotationState.x = timeRotation;
    
    // STEP 6: Write results
    entityBuffers[VELOCITY_BUFFER].data[entityIndex] = vec4(vel, damping);
    entityBuffers[ROTATION_STATE_BUFFER].data[entityIndex] = rotationState;
    entityBuffers[MODEL_MATRIX_BUFFER].data[entityIndex * 4 + 3] = vec4(currentPosition, 1.0);
}