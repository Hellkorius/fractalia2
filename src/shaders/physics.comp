#version 450
#extension GL_EXT_nonuniform_qualifier : require
#extension GL_GOOGLE_include_directive : require

// Include shared entity buffer indices
#include "entity_buffer_indices.glsl"

// Optimized workgroup size for maximum GPU occupancy
layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

// Push constants for timing and control (matching NodePushConstants from CPU)
layout(push_constant) uniform NodePushConstants {
    float time;
    float deltaTime;
    uint entityCount;
    uint frame;
    uint param1;            // entityOffset for chunked dispatches
    uint param2;            // Future expansion
    float gravityStrength;  // Gravity acceleration (e.g., 9.81)
    float restitution;      // Bounce factor (0.0-1.0)
    float friction;         // Surface friction (0.0-1.0)
    uint padding;           // Alignment padding
} pc;

// Vulkan 1.3 descriptor indexing - single array of all entity buffers
layout(std430, binding = 1) buffer EntityBuffers {
    vec4 data[];
} entityBuffers[];

// Spatial buffers use dedicated bindings with proper types for atomic operations
layout(std430, binding = 2) buffer SpatialMapBuffer {
    uvec2 cellMetadata[];     // [entityCount, entityOffset] per cell
} spatialMap;

layout(std430, binding = 10) buffer SpatialEntitiesBuffer {
    uint entityIndices[];     // Flat array: [cell0_entities...][cell1_entities...]...
} spatialEntities;

/* ---------- Spatial Map Constants and Functions ---------- */

// 3D Spatial grid configuration - cache-optimized
const float CELL_SIZE = 2.0;           // Size of each spatial cell (must be larger than collision radius)
const uint GRID_WIDTH = 64;            // Increased for better distribution
const uint GRID_HEIGHT = 64;           // Power-of-2 for fast modulo
const uint GRID_DEPTH = 8;             // Reduced depth for cache locality
const uint SPATIAL_MAP_SIZE = GRID_WIDTH * GRID_HEIGHT * GRID_DEPTH; // 32768 cells
const uint MAX_ENTITIES_PER_CELL = 32; // Safety limit for collision detection

// Clean spatial buffer access using proper types - no workarounds needed

// Initialize spatial map buffer offsets (called once per frame) 
void initializeSpatialMap() {
    uint globalIndex = gl_GlobalInvocationID.x;
    
    // Parallel initialization: each thread clears one cell
    if (globalIndex < SPATIAL_MAP_SIZE) {
        spatialMap.cellMetadata[globalIndex].x = 0; // entityCount = 0
        // entityOffset is set once during CPU buffer setup and doesn't change
    }
    
    // Ensure all threads wait for initialization
    barrier();
    memoryBarrierBuffer();
}

// Cache-friendly 3D access pattern constants
const uint Z_STRIDE = GRID_WIDTH * GRID_HEIGHT;  // 4096 - one cache line per Z level
const uint Y_STRIDE = GRID_WIDTH;                // 64 - fits in cache line

// 3D Collision detection configuration - GENEROUS for debugging  
const float CUBE_RADIUS = 1.2;            // Large bounding sphere radius for cube (was 0.8)
const float MIN_SEPARATION = 0.3;         // Minimum separation distance

// Cache-optimized 3D spatial hash function
uint spatialHash3D(vec3 position) {
    // Convert world position to grid coordinates
    ivec3 gridCoord = ivec3(floor(position / CELL_SIZE));
    
    // Wrap to grid bounds using bitwise AND (requires power-of-2 dimensions)
    uint x = uint(gridCoord.x) & (GRID_WIDTH - 1);
    uint y = uint(gridCoord.y) & (GRID_HEIGHT - 1);
    uint z = uint(gridCoord.z) & (GRID_DEPTH - 1);
    
    // Cache-friendly layout: Z-order curve for spatial locality
    // Interleave bits: Z layers grouped for cache coherency
    return x + (y << 6) + (z << 12);  // x + y*64 + z*4096
}

// Calculate entity bounds from model matrix
struct EntityBounds {
    vec3 minBounds;
    vec3 maxBounds;
};

EntityBounds calculateEntityBounds(uint entityIndex, vec3 position) {
    // Use fixed entity size for spatial hash (don't rely on model matrix scaling)
    vec3 halfSize = vec3(CUBE_RADIUS, CUBE_RADIUS, CUBE_RADIUS); // Fixed cube half-size
    
    EntityBounds bounds;
    bounds.minBounds = position - halfSize;
    bounds.maxBounds = position + halfSize;
    return bounds;
}

/* ---------- Entity Type Constants ---------- */

// Entity type definitions (must match CPU EntityType enum)  
const float ENTITY_TYPE_REGULAR = 0.0;
const float ENTITY_TYPE_FLOOR = 1.0;

// Helper function to check entity type from runtime state
bool isFloorEntity(uint entityIndex) {
    vec4 runtimeState = entityBuffers[RUNTIME_STATE_BUFFER].data[entityIndex];
    return abs(runtimeState.y - ENTITY_TYPE_FLOOR) < 0.1; // .y contains entityType
}

// Bespoke floor entity spatial occupancy - ensures massive floor coverage
void insertFloorEntityIntoCells(uint entityIndex, vec3 position) {
    // Floor entities are MASSIVE (1000×2×1000 units) and need comprehensive spatial coverage
    // For floor at Y=-5 with scale (1000, 2, 1000), we need cells from roughly:
    // X: [-500 to +500] / CELL_SIZE = [-250 to +250] cells  
    // Y: [-6 to -4] / CELL_SIZE = [-3 to -2] cells
    // Z: [-500 to +500] / CELL_SIZE = [-250 to +250] cells
    
    // Calculate floor bounds from model matrix scale
    vec3 col0 = entityBuffers[MODEL_MATRIX_BUFFER].data[entityIndex * 4 + 0].xyz;
    vec3 col1 = entityBuffers[MODEL_MATRIX_BUFFER].data[entityIndex * 4 + 1].xyz;
    vec3 col2 = entityBuffers[MODEL_MATRIX_BUFFER].data[entityIndex * 4 + 2].xyz;
    vec3 scale = vec3(length(col0), length(col1), length(col2));
    vec3 halfSize = scale * 0.5;
    
    vec3 minBounds = position - halfSize;
    vec3 maxBounds = position + halfSize;
    
    // Convert to spatial cell coordinates
    ivec3 minCell = ivec3(floor(minBounds / CELL_SIZE));
    ivec3 maxCell = ivec3(floor(maxBounds / CELL_SIZE));
    
    // Clamp to grid bounds
    minCell = max(minCell, ivec3(0));
    maxCell = min(maxCell, ivec3(int(GRID_WIDTH-1), int(GRID_HEIGHT-1), int(GRID_DEPTH-1)));
    
    // Insert floor into ALL cells it occupies (this will be MANY cells)
    for (int z = minCell.z; z <= maxCell.z; z++) {
        for (int y = minCell.y; y <= maxCell.y; y++) {
            for (int x = minCell.x; x <= maxCell.x; x++) {
                uint cellIndex = uint(x) + (uint(y) << 6) + (uint(z) << 12);
                
                if (cellIndex < SPATIAL_MAP_SIZE) {
                    // ATOMIC RESERVATION for floor entity - proper types, proper atomics
                    uint reservedSlot = atomicAdd(spatialMap.cellMetadata[cellIndex].x, 1);
                    uint entityOffset = spatialMap.cellMetadata[cellIndex].y;
                    
                    // Floor entity gets priority - always try to insert
                    if (reservedSlot < MAX_ENTITIES_PER_CELL) {
                        uint insertIndex = entityOffset + reservedSlot;
                        if (insertIndex < spatialEntities.entityIndices.length()) {
                            spatialEntities.entityIndices[insertIndex] = entityIndex;
                        }
                    } else {
                        // Rollback on overflow - floor is critical so this shouldn't happen
                        atomicAdd(spatialMap.cellMetadata[cellIndex].x, -1);
                    }
                }
            }
        }
    }
}

// Regular entity spatial insertion - smaller entities
void insertRegularEntityIntoCells(uint entityIndex, vec3 position) {
    if (entityIndex >= pc.entityCount) return;
    
    EntityBounds bounds = calculateEntityBounds(entityIndex, position);
    
    // Calculate spatial cell range that this entity occupies
    ivec3 minCell = ivec3(floor(bounds.minBounds / CELL_SIZE));
    ivec3 maxCell = ivec3(floor(bounds.maxBounds / CELL_SIZE));
    
    // Clamp to grid bounds
    minCell = max(minCell, ivec3(0));
    maxCell = min(maxCell, ivec3(int(GRID_WIDTH-1), int(GRID_HEIGHT-1), int(GRID_DEPTH-1)));
    
    // Add entity to cells it occupies
    for (int z = minCell.z; z <= maxCell.z; z++) {
        for (int y = minCell.y; y <= maxCell.y; y++) {
            for (int x = minCell.x; x <= maxCell.x; x++) {
                uint cellIndex = uint(x) + (uint(y) << 6) + (uint(z) << 12);
                
                if (cellIndex < SPATIAL_MAP_SIZE) {
                    // ATOMIC RESERVATION - prevents race condition, proper types
                    uint reservedSlot = atomicAdd(spatialMap.cellMetadata[cellIndex].x, 1);
                    uint entityOffset = spatialMap.cellMetadata[cellIndex].y;
                    
                    // Safety check with atomic count
                    if (reservedSlot < MAX_ENTITIES_PER_CELL) {
                        uint insertIndex = entityOffset + reservedSlot;
                        if (insertIndex < spatialEntities.entityIndices.length()) {
                            spatialEntities.entityIndices[insertIndex] = entityIndex;
                        }
                    } else {
                        // Rollback on overflow
                        atomicAdd(spatialMap.cellMetadata[cellIndex].x, -1);
                    }
                }
            }
        }
    }
}

// Removed cached floor collision system to prevent conflicts with hardcoded system

// Solid surface collision system - proper physics response
bool checkFloorCollision(vec3 entityPosition, out vec3 resolvedPosition, inout vec3 velocity) {
    // Hardcoded floor properties (matches control_service.cpp creation)
    vec3 floorCenter = vec3(0.0, -5.0, 0.0);
    vec3 floorScale = vec3(1000.0, 2.0, 1000.0);
    vec3 floorHalfSize = floorScale * 0.5;
    float entityRadius = 0.8;
    
    // Calculate floor bounds
    vec3 floorMin = floorCenter - floorHalfSize;
    vec3 floorMax = floorCenter + floorHalfSize;
    
    // Check if entity is within horizontal bounds of floor
    if (entityPosition.x < floorMin.x - entityRadius || entityPosition.x > floorMax.x + entityRadius ||
        entityPosition.z < floorMin.z - entityRadius || entityPosition.z > floorMax.z + entityRadius) {
        return false; // Outside floor horizontal bounds
    }
    
    // Calculate closest point on floor surface to entity
    vec3 closestPoint = clamp(entityPosition, floorMin, floorMax);
    vec3 difference = entityPosition - closestPoint;
    float distance = length(difference);
    
    // Check if entity is colliding with floor
    if (distance < entityRadius) {
        // Collision detected - resolve it
        if (distance > 0.001) {
            // Calculate collision normal (direction to push entity)
            vec3 normal = normalize(difference);
            
            // Position entity just outside floor surface
            resolvedPosition = closestPoint + normal * entityRadius;
            
            // Apply physics response to velocity
            float velocityAlongNormal = dot(velocity, normal);
            
            if (velocityAlongNormal < 0.0) {
                // Moving into surface - preserve XZ movement for floor collisions
                
                // For floor collision, we mainly care about Y-axis (vertical)
                if (abs(normal.y) > 0.7) { // This is primarily a floor (horizontal surface)
                    // Only modify Y velocity, preserve XZ completely
                    velocity.y = -velocity.y * 0.3; // Bounce Y with restitution
                    // Keep velocity.x and velocity.z unchanged for smooth sliding
                } else {
                    // For walls or other surfaces, use full physics
                    vec3 normalVelocity = velocityAlongNormal * normal;
                    vec3 tangentVelocity = velocity - normalVelocity;
                    
                    float restitution = 0.3;
                    vec3 newNormalVelocity = -normalVelocity * restitution;
                    
                    float friction = 0.9; // Less friction for walls
                    vec3 newTangentVelocity = tangentVelocity * friction;
                    
                    velocity = newNormalVelocity + newTangentVelocity;
                }
            }
            
            return true;
        } else {
            // Entity exactly on surface - just push up slightly
            resolvedPosition = entityPosition + vec3(0, entityRadius, 0);
            velocity.y = max(velocity.y, 0.0); // Prevent downward velocity
            return true;
        }
    }
    
    return false; // No collision
}

// Unified insertion function - all entities go to spatial hash (floor collisions handled separately)
void insertEntityIntoCells(uint entityIndex, vec3 position) {
    if (entityIndex >= pc.entityCount) return;
    
    // All entities (including floors) go into spatial hash for entity-entity collisions
    // Floor collisions are handled by the hardcoded checkFloorCollision() function
    if (!isFloorEntity(entityIndex)) {
        // Only regular entities need spatial hash insertion
        insertRegularEntityIntoCells(entityIndex, position);
    }
    // Floor entities skip spatial hash since they don't move or need entity-entity collision
}

/* ---------- Collision Detection Constants and Functions ---------- */

// Gold standard bucketed hash table entity collection
uint collectEntitiesInCell(uint cellIndex, out uint entities[MAX_ENTITIES_PER_CELL]) {
    if (cellIndex >= SPATIAL_MAP_SIZE) return 0;
    
    // Get cell metadata directly from proper buffer types
    uvec2 cellData = spatialMap.cellMetadata[cellIndex];
    uint entityCount = min(cellData.x, MAX_ENTITIES_PER_CELL); // Safety clamp
    uint entityOffset = cellData.y;
    
    // Copy entities from flat array to local array
    for (uint i = 0; i < entityCount; i++) {
        uint sourceIndex = entityOffset + i;
        if (sourceIndex < spatialEntities.entityIndices.length()) {
            entities[i] = spatialEntities.entityIndices[sourceIndex];
        } else {
            // Safety: truncate if buffer bounds exceeded
            return i;
        }
    }
    
    return entityCount;
}

// 3D Sphere-sphere collision test
bool sphereCollision3D(vec3 pos1, vec3 pos2, float radius1, float radius2) {
    vec3 diff = pos2 - pos1;
    float distSq = dot(diff, diff);
    float radiusSum = radius1 + radius2;
    return distSq < (radiusSum * radiusSum);
}

// Resolve 3D collision with separation force
vec3 resolveCollision3D(vec3 currentPos, vec3 otherPos) {
    vec3 diff = currentPos - otherPos;
    float distSq = dot(diff, diff);
    
    // Calculate safe distance (sum of bounding radii + separation)
    float safeDistance = CUBE_RADIUS * 2.0 + MIN_SEPARATION;
    float safeDistanceSq = safeDistance * safeDistance;
    
    if (distSq < safeDistanceSq && distSq > 0.000001) {
        // Force separation - push entity away from collision
        float invDist = inversesqrt(distSq); // Fast inverse sqrt
        vec3 separationDir = diff * invDist;
        
        // Position entity at safe distance away from other entity
        return otherPos + separationDir * safeDistance;
    }
    
    return currentPos; // No collision resolution needed
}


void main() {
    // Initialize spatial map with bucketed hash table approach
    initializeSpatialMap();
    
    // Get current entity index with chunk offset
    uint entityIndex = gl_GlobalInvocationID.x + pc.param1;
    
    // Early exit for out-of-bounds entities
    if (entityIndex >= pc.entityCount) {
        return;
    }
    
    // Load entity data from SoA buffers - better cache locality
    vec4 velocity = entityBuffers[VELOCITY_BUFFER].data[entityIndex];
    vec4 runtimeState = entityBuffers[RUNTIME_STATE_BUFFER].data[entityIndex];
    vec4 rotationState = entityBuffers[ROTATION_STATE_BUFFER].data[entityIndex];
    
    float initialized = runtimeState.w; // initialized flag is in .w
    float entityType = runtimeState.y;  // entity type in .y
    
    // Extract velocity and damping (now supporting 3D velocity)
    vec3 vel = velocity.xyz;
    float damping = velocity.w;
    
    // NEW MVP APPROACH: Extract position from model matrix (column 3)
    vec3 currentPosition = entityBuffers[MODEL_MATRIX_BUFFER].data[entityIndex * 4 + 3].xyz;
    
    // Skip physics for floor entities (they don't move)
    bool isFloor = abs(entityType - ENTITY_TYPE_FLOOR) < 0.1;
    if (isFloor) {
        // Floor entities are static - but they need position initialization too
        // If floor position is zero, it means it hasn't been initialized yet
        if (length(currentPosition) < 0.01) {
            // Floor entities get their position from their initial setup
            // For now, use a default floor position - this should be set by the CPU
            currentPosition = vec3(0.0, -5.0, 0.0);  // Floor at Y=-5 (gravity pulls down in Y)
        }
        
        // Update spatial map for collision detection
        insertEntityIntoCells(entityIndex, currentPosition);
        return;
    }
    
    // On first frame, initialize position if it's zero
    if (length(currentPosition) < 0.01) {
        // TIGHTER SPAWN: Use smaller spacing to encourage collisions for testing
        float gridX = float(entityIndex % 50) * 1.0 - 25.0;  // Tighter X spread: -25 to +25 (50 units wide)
        float gridY = float((entityIndex / 50) % 50) * 1.0 - 25.0;  // Tighter Y spread: -25 to +25 (50 units wide)
        float gridZ = float(entityIndex / 2500) * 2.0 - 10.0;  // Tighter Z layers: -10 to +10
        
        // Small randomization to prevent perfect grid alignment
        uint seed = entityIndex * 2654435761u;
        float randX = (float(seed & 0xFFFFu) / 65535.0 - 0.5) * 0.8; // Small randomness
        seed = seed * 1664525u + 1013904223u;
        float randY = (float(seed & 0xFFFFu) / 65535.0 - 0.5) * 0.8;  
        seed = seed * 1664525u + 1013904223u;
        float randZ = (float(seed & 0xFFFFu) / 65535.0 - 0.5) * 1.5;
        
        currentPosition = vec3(gridX + randX, gridY + randY + 15.0, gridZ + randZ); // Spawn above floor, tighter clustering
        
        // Initialize model matrix position immediately
        entityBuffers[MODEL_MATRIX_BUFFER].data[entityIndex * 4 + 3] = vec4(currentPosition, 1.0);
    }
    
    // Apply gravity to regular entities only (floor entities don't have physics)
    vel.y -= pc.gravityStrength * pc.deltaTime;
    
    // Physics integration: position += velocity * deltaTime (3D movement)
    if (length(vel) > 0.01) {
        // Normalized physics integration (removed excessive multiplier)
        currentPosition.x += vel.x * pc.deltaTime * 5.0; // Reduced from 15.0 to 5.0
        currentPosition.y += vel.y * pc.deltaTime * 5.0;
        currentPosition.z += vel.z * pc.deltaTime * 5.0;
    }
    
    // Moderate damping to balance frequent updates with momentum retention (3D)
    vel *= 0.998;
    
    // Generate individual rotation physics directly in physics shader
    float baseRotation = float(entityIndex % 360) * 0.01745; // Individual base rotation (degrees to radians)
    float timeRotation = sin(pc.time * 0.1 + baseRotation) * 0.5; // Individual oscillation
    rotationState.x = timeRotation;
    
    // Write tentative position to model matrix translation (column 3)
    entityBuffers[MODEL_MATRIX_BUFFER].data[entityIndex * 4 + 3] = vec4(currentPosition, 1.0);
    
    // Insert entity into spatial hash at current position
    insertEntityIntoCells(entityIndex, currentPosition);
    
    // Wait for all entities to populate spatial hash before collision detection
    barrier();
    memoryBarrierBuffer();
    
    // 3D Collision detection - single unified floor collision system
    vec3 resolvedPosition = currentPosition;
    bool hadCollision = false;
    
    // SINGLE FLOOR COLLISION: Use only the hardcoded system to prevent conflicts
    if (checkFloorCollision(currentPosition, resolvedPosition, vel)) {
        hadCollision = true;
        currentPosition = resolvedPosition; // Apply floor collision immediately
        
        // Immediately update model matrix with floor collision resolution
        entityBuffers[MODEL_MATRIX_BUFFER].data[entityIndex * 4 + 3] = vec4(currentPosition, 1.0);
        
        // DON'T re-insert after floor collision - we'll do one final insert at the end
    }
    
    // Pre-calculate collision parameters for spatial hash (unified with resolveCollision3D)
    const float collisionRadius = CUBE_RADIUS * 2.0 + MIN_SEPARATION; // 2.2 total
    const float collisionRadiusSq = collisionRadius * collisionRadius;
    
    // ALWAYS check spatial hash for entity-entity collisions (independent of floor collisions)
    {
        // Get our spatial cell
        uint cellIndex = spatialHash3D(currentPosition);
    
    // Expanded 3D neighborhood: 27 cells (3x3x3 cube) for better collision detection
    // Ensures floor collision detection works properly across cell boundaries
    const int offsets[27][3] = int[27][3](
        // Current layer (z=0)
        int[3](-1, -1, 0), int[3](0, -1, 0), int[3](1, -1, 0),
        int[3](-1,  0, 0), int[3](0,  0, 0), int[3](1,  0, 0),
        int[3](-1,  1, 0), int[3](0,  1, 0), int[3](1,  1, 0),
        // Below layer (z=-1)  
        int[3](-1, -1, -1), int[3](0, -1, -1), int[3](1, -1, -1),
        int[3](-1,  0, -1), int[3](0,  0, -1), int[3](1,  0, -1),
        int[3](-1,  1, -1), int[3](0,  1, -1), int[3](1,  1, -1),
        // Above layer (z=1)
        int[3](-1, -1, 1), int[3](0, -1, 1), int[3](1, -1, 1),
        int[3](-1,  0, 1), int[3](0,  0, 1), int[3](1,  0, 1),
        int[3](-1,  1, 1), int[3](0,  1, 1), int[3](1,  1, 1)
    );
    
    for (int cellIdx = 0; cellIdx < 27; cellIdx++) {
        int dx = offsets[cellIdx][0];
        int dy = offsets[cellIdx][1];
        int dz = offsets[cellIdx][2];
        
        // Calculate neighbor cell using cache-optimized addressing
        uint currentX = cellIndex & (GRID_WIDTH - 1);
        uint currentY = (cellIndex >> 6) & (GRID_HEIGHT - 1);
        uint currentZ = (cellIndex >> 12) & (GRID_DEPTH - 1);
        
        // Apply offset with proper wrapping (handle negative offsets correctly)
        uint neighborX = (currentX + uint(dx + int(GRID_WIDTH))) & (GRID_WIDTH - 1);
        uint neighborY = (currentY + uint(dy + int(GRID_HEIGHT))) & (GRID_HEIGHT - 1);
        uint neighborZ = (currentZ + uint(dz + int(GRID_DEPTH))) & (GRID_DEPTH - 1);
        
        // Cache-friendly neighbor calculation
        uint neighborCell = neighborX + (neighborY << 6) + (neighborZ << 12);
        
        // Collect entities in this neighboring cell
        uint entitiesInCell[MAX_ENTITIES_PER_CELL];
        uint entityCount = collectEntitiesInCell(neighborCell, entitiesInCell);
        
        // Check collision with entities in this cell
        for (uint i = 0; i < entityCount; i++) {
            uint otherEntityIndex = entitiesInCell[i];
            if (otherEntityIndex == entityIndex) continue; // Skip self
            if (otherEntityIndex >= pc.entityCount) continue;
            
            // Get other entity's transform from model matrix
            vec3 otherPos = entityBuffers[MODEL_MATRIX_BUFFER].data[otherEntityIndex * 4 + 3].xyz;
            
            // Regular entity-entity collision - sphere vs sphere
            // (Floor collisions are now handled by cached collision system)
            if (!isFloorEntity(otherEntityIndex)) {
                vec3 diff = currentPosition - otherPos;
                float distSq = dot(diff, diff);
                
                if (distSq < collisionRadiusSq && distSq > 0.000001) {
                    currentPosition = resolveCollision3D(currentPosition, otherPos);
                    // STRONGER collision response for better visibility
                    vel *= 0.5; // Stronger dampening to make collisions more obvious
                    
                    // Immediately update model matrix with resolved position
                    entityBuffers[MODEL_MATRIX_BUFFER].data[entityIndex * 4 + 3] = vec4(currentPosition, 1.0);
                    
                    // DON'T re-insert after entity collision - we'll do one final insert at the end
                    
                    hadCollision = true;
                    break; // Handle first collision only
                }
            }
        }
        
        if (hadCollision) break; // Exit loop
    }
    } // End of spatial hash collision check
    
    // Write back final velocity, rotation state, and current position to model matrix
    entityBuffers[VELOCITY_BUFFER].data[entityIndex] = vec4(vel, damping);
    entityBuffers[ROTATION_STATE_BUFFER].data[entityIndex] = rotationState;
    entityBuffers[MODEL_MATRIX_BUFFER].data[entityIndex * 4 + 3] = vec4(currentPosition, 1.0);
}