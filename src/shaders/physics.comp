#version 450

// Optimized workgroup size for maximum GPU occupancy
layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

// Push constants for timing and control
layout(push_constant) uniform PhysicsPushConstants {
    float time;
    float deltaTime;
    uint entityCount;
    uint frame;
    uint entityOffset;  // For chunked dispatches
} pc;

// Input: GPUEntity buffer (read-only for velocity, read-write for position tracking)
layout(std430, binding = 0) buffer GPUEntityBuffer {
    // Cache-optimized GPUEntity structure (128 bytes each):
    // C++ struct layout:
    //   vec4 velocity (16 bytes) - position 0: velocity.xy, damping, reserved
    //   vec4 movementParams (16 bytes) - position 1: amplitude, frequency, phase, timeOffset
    //   vec4 runtimeState (16 bytes) - position 2: totalTime, initialized, stateTimer, entityState
    //   vec4 color (16 bytes) - position 3: RGBA color
    //   mat4 modelMatrix (64 bytes) - positions 4-7: transform matrix (graphics only)
    vec4 entityData[];
} entities;

// Output: Computed positions (write-only)
layout(std430, binding = 1) writeonly buffer PositionBuffer {
    vec4 positions[]; // xyz position + w unused
} outPositions;

// Current positions for physics integration (read/write)
layout(std430, binding = 2) buffer CurrentPositionBuffer {
    vec4 currentPositions[]; // xyz current position + w unused
} currentPos;

// Target positions buffer (unused in physics, kept for compatibility)
layout(std430, binding = 3) buffer TargetPositionBuffer {
    vec4 targetPositions[]; // xyz target position + w unused
} targetPos;

void main() {
    // Get current entity index with chunk offset
    uint entityIndex = gl_GlobalInvocationID.x + pc.entityOffset;
    
    // Early exit for out-of-bounds entities
    if (entityIndex >= pc.entityCount) {
        return;
    }
    
    // Calculate base offset for this entity (8 vec4s per entity = 128 bytes)
    uint baseOffset = entityIndex * 8u;
    
    // Load entity data
    vec4 velocity = entities.entityData[baseOffset];           // position 0: velocity
    vec4 runtimeState = entities.entityData[baseOffset + 2u];   // position 2: runtime state
    
    vec2 center = runtimeState.xy;     // center position
    float initialized = runtimeState.w; // initialized flag is now in .w
    
    // Extract velocity and damping
    vec2 vel = velocity.xy;
    float damping = velocity.z;
    
    // Load or initialize current position
    vec3 currentPosition;
    if (initialized < 0.5) {
        // Initialize new entity at center position
        currentPosition = vec3(center, 0.0);
        currentPos.currentPositions[entityIndex] = vec4(currentPosition, 1.0);
        // Mark as initialized in physics (movement shader may have already done this)
        entities.entityData[baseOffset + 2u].w = 1.0;
    } else {
        // Load existing position
        currentPosition = currentPos.currentPositions[entityIndex].xyz;
    }
    
    // Physics integration: position += velocity * deltaTime
    currentPosition.x += vel.x * pc.deltaTime * 60.0; // Scale for 60fps target
    currentPosition.y += vel.y * pc.deltaTime * 60.0;
    
    // Apply damping to velocity (reduce over time)
    vel *= (1.0 - damping);
    
    // Write updated velocity back to entity buffer
    entities.entityData[baseOffset].xy = vel;
    
    // Write updated position to both position buffers
    vec4 newPosition = vec4(currentPosition, 1.0);
    currentPos.currentPositions[entityIndex] = newPosition;
    outPositions.positions[entityIndex] = newPosition;
}