#version 450

// Optimized workgroup size for maximum GPU occupancy
layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

// Push constants for timing and control
layout(push_constant) uniform PhysicsPushConstants {
    float time;
    float deltaTime;
    uint entityCount;
    uint frame;
    uint entityOffset;  // For chunked dispatches
} pc;

// Unified SoA binding layout (shared with movement shader)
layout(std430, binding = 0) buffer VelocityBuffer {
    vec4 velocities[];  // R/W: velocity.xy, damping, reserved
} velocityBuffer;

layout(std430, binding = 2) buffer RuntimeStateBuffer {
    vec4 runtimeStates[];  // R/W: totalTime, reserved, stateTimer, initialized
} runtimeStateBuffer;

// Physics-specific buffers
layout(std430, binding = 3) buffer PositionBuffer {
    vec4 positions[]; // RW: computed positions for graphics
} outPositions;

layout(std430, binding = 4) buffer CurrentPositionBuffer {
    vec4 currentPositions[]; // R/W: physics integration state
} currentPos;

// Spatial map buffer for collision detection and spatial queries
layout(std430, binding = 7) buffer SpatialMapBuffer {
    uvec2 spatialCells[]; // R/W: spatial hash grid - packed (entityId, nextIndex)
} spatialMap;

/* ---------- Spatial Map Constants and Functions ---------- */

// Spatial grid configuration
const float CELL_SIZE = 2.0;           // Size of each spatial cell
const uint GRID_WIDTH = 64;            // Grid dimensions (must be power of 2)
const uint GRID_HEIGHT = 64;
const uint SPATIAL_MAP_SIZE = GRID_WIDTH * GRID_HEIGHT; // 4096 cells
const uint NULL_INDEX = 0xFFFFFFFF;    // Null pointer for linked list

// Fast spatial hash function using bit mixing
uint spatialHash(vec2 position) {
    // Convert world position to grid coordinates
    ivec2 gridCoord = ivec2(floor(position / CELL_SIZE));
    
    // Wrap to grid bounds using bitwise AND (requires power-of-2 dimensions)
    uint x = uint(gridCoord.x) & (GRID_WIDTH - 1);
    uint y = uint(gridCoord.y) & (GRID_HEIGHT - 1);
    
    // Simple hash: x + y * width
    return x + y * GRID_WIDTH;
}

// Update spatial map entry for this entity
void updateSpatialMap(uint entityIndex, vec2 position) {
    uint cellIndex = spatialHash(position);
    
    // Atomic compare-swap loop to safely update the linked list head
    uint expectedHead;
    do {
        expectedHead = spatialMap.spatialCells[cellIndex].x;
    } while (atomicCompSwap(spatialMap.spatialCells[cellIndex].x, expectedHead, entityIndex) != expectedHead);
    
    // Store old head as our next pointer (building linked list)
    spatialMap.spatialCells[cellIndex].y = expectedHead;
}

void main() {
    // Clear spatial cells (each thread clears one cell)
    if (gl_GlobalInvocationID.x < SPATIAL_MAP_SIZE) {
        spatialMap.spatialCells[gl_GlobalInvocationID.x] = uvec2(NULL_INDEX, NULL_INDEX);
    }
    barrier();
    memoryBarrierShared();
    
    // Get current entity index with chunk offset
    uint entityIndex = gl_GlobalInvocationID.x + pc.entityOffset;
    
    // Early exit for out-of-bounds entities
    if (entityIndex >= pc.entityCount) {
        return;
    }
    
    // Load entity data from SoA buffers - better cache locality
    vec4 velocity = velocityBuffer.velocities[entityIndex];
    vec4 runtimeState = runtimeStateBuffer.runtimeStates[entityIndex];
    
    float initialized = runtimeState.w; // initialized flag is in .w
    
    // Extract velocity and damping
    vec2 vel = velocity.xy;
    float damping = velocity.z;
    
    // SIMPLIFIED: Read position directly from output buffer, integrate velocity
    vec3 currentPosition = outPositions.positions[entityIndex].xyz;
    
    // On first frame, initialize position if it's zero
    if (length(currentPosition) < 0.01) {
        // Use spawn position from entity index (simple grid)
        currentPosition = vec3(
            float(entityIndex % 10) * 0.8 - 4.0,
            float(entityIndex / 10) * 0.8 - 4.0, 
            0.0
        );
    }
    
    // Physics integration: position += velocity * deltaTime (only if velocity is non-zero)
    if (length(vel) > 0.01) {
        currentPosition.x += vel.x * pc.deltaTime * 10.0;
        currentPosition.y += vel.y * pc.deltaTime * 10.0;
    }
    
    // Apply very light damping to velocity (much less damping)
    vel *= 0.999;
    
    // Write back velocity and position
    velocityBuffer.velocities[entityIndex].xy = vel;
    outPositions.positions[entityIndex] = vec4(currentPosition, 1.0);
    
    // Update spatial map with new position
    updateSpatialMap(entityIndex, currentPosition.xy);
}