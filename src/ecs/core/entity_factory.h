#pragma once

#include "../components/entity.h"
#include "../components/component.h"
#include <memory>
#include <functional>
#include <vector>
#include <random>

// Entity builder pattern for designer-friendly workflow
class EntityBuilder {
private:
    flecs::entity entity;
    
public:
    EntityBuilder(flecs::entity e) : entity(e) {}
    
    // Transform methods
    EntityBuilder& at(const glm::vec3& position) {
        if (auto* transform = entity.get_mut<Transform>()) {
            transform->setPosition(position);
        } else {
            entity.set<Transform>({.position = position});
        }
        return *this;
    }
    
    EntityBuilder& at(float x, float y, float z = 0.0f) {
        return at(glm::vec3(x, y, z));
    }
    
    EntityBuilder& rotated(const glm::vec3& rotation) {
        if (auto* transform = entity.get_mut<Transform>()) {
            transform->setRotation(rotation);
        } else {
            auto t = entity.get_mut<Transform>();
            if (!t) {
                entity.set<Transform>({});
                t = entity.get_mut<Transform>();
            }
            t->setRotation(rotation);
        }
        return *this;
    }
    
    EntityBuilder& scaled(const glm::vec3& scale) {
        if (auto* transform = entity.get_mut<Transform>()) {
            transform->setScale(scale);
        } else {
            auto t = entity.get_mut<Transform>();
            if (!t) {
                entity.set<Transform>({});
                t = entity.get_mut<Transform>();
            }
            t->setScale(scale);
        }
        return *this;
    }
    
    // Rendering methods - shapes are now handled uniformly by GPU
    
    EntityBuilder& withColor(const glm::vec4& color) {
        if (auto* renderable = entity.get_mut<Renderable>()) {
            renderable->color = color;
            renderable->markDirty();
        } else {
            auto r = entity.get_mut<Renderable>();
            if (!r) {
                entity.set<Renderable>({});
                r = entity.get_mut<Renderable>();
            }
            r->color = color;
        }
        return *this;
    }
    
    EntityBuilder& withColor(float r, float g, float b, float a = 1.0f) {
        return withColor(glm::vec4(r, g, b, a));
    }
    
    EntityBuilder& onLayer(uint32_t layer) {
        if (auto* renderable = entity.get_mut<Renderable>()) {
            renderable->layer = layer;
            renderable->markDirty();
        } else {
            auto r = entity.get_mut<Renderable>();
            if (!r) {
                entity.set<Renderable>({});
                r = entity.get_mut<Renderable>();
            }
            r->layer = layer;
        }
        return *this;
    }
    
    // Physics methods
    EntityBuilder& withVelocity(const glm::vec3& linear, const glm::vec3& angular = glm::vec3(0.0f)) {
        entity.set<Velocity>({.linear = linear, .angular = angular});
        return *this;
    }
    
    EntityBuilder& withBounds(const glm::vec3& min, const glm::vec3& max) {
        entity.set<Bounds>({.min = min, .max = max});
        return *this;
    }
    
    // Lifetime methods
    EntityBuilder& withLifetime(float maxAge, bool autoDestroy = true) {
        entity.set<Lifetime>({.maxAge = maxAge, .autoDestroy = autoDestroy});
        return *this;
    }
    
    // Tag methods
    EntityBuilder& asStatic() {
        entity.add<Static>();
        entity.remove<Dynamic>();
        return *this;
    }
    
    EntityBuilder& asDynamic() {
        entity.add<Dynamic>();
        entity.remove<Static>();
        return *this;
    }
    
    EntityBuilder& asPooled() {
        entity.add<Pooled>();
        return *this;
    }
    
    // Finish building
    flecs::entity build() {
        return entity;
    }
};

// Entity factory with pooling support
class EntityFactory {
private:
    flecs::world& world;
    std::vector<flecs::entity> entityPool;
    std::mt19937 rng{std::random_device{}()};
    
    // Note: Dynamic colors are now generated by the movement system based on amplitude/frequency
    
    // Helper function to create movement patterns with specified type
    MovementPattern createMovementPattern(const glm::vec3& center, size_t index, size_t totalCount, MovementType type = MovementType::RandomWalk) {
        MovementPattern pattern;
        pattern.type = type;
        pattern.center = center; // Set the movement center!
        
        // Create variation based on entity index
        float t = static_cast<float>(index) / static_cast<float>(totalCount);
        
        // Simple parameters for active movement
        pattern.amplitude = 12.0f + 8.0f * t; // Larger radius for more active movement
        pattern.frequency = 0.8f + 1.2f * t; // Higher frequency for more dynamic behavior
        pattern.phase = t * 6.28318530718f * 2.0f; // Phase variation
        pattern.timeOffset = t * 10.0f; // Stagger timing
        
        return pattern;
    }
    
public:
    EntityFactory(flecs::world& w) : world(w) {
        entityPool.reserve(1000); // Pre-allocate pool
    }
    
    // Create new entity or reuse from pool
    EntityBuilder create() {
        flecs::entity entity;
        
        // Try to reuse pooled entity
        if (!entityPool.empty()) {
            entity = entityPool.back();
            entityPool.pop_back();
            
            // Clear existing components
            entity.clear();
        } else {
            entity = world.entity();
        }
        
        return EntityBuilder(entity);
    }
    
    // Return entity to pool for reuse
    void recycle(flecs::entity entity) {
        if (entity.is_valid() && entity.has<Pooled>()) {
            // Clear components but keep entity alive
            entity.clear();
            entityPool.push_back(entity);
        }
    }
    
    // Batch creation methods for performance
    std::vector<flecs::entity> createBatch(size_t count, std::function<void(EntityBuilder&, size_t)> configure) {
        std::vector<flecs::entity> entities;
        entities.reserve(count);
        
        for (size_t i = 0; i < count; ++i) {
            auto builder = create();
            if (configure) {
                configure(builder, i);
            }
            entities.push_back(builder.build());
        }
        
        return entities;
    }
    
    // Predefined entity types for common use cases
    flecs::entity createEntity(const glm::vec3& pos, const glm::vec4& color, uint32_t layer = 0) {
        return create()
            .at(pos)
            .withColor(color)
            .onLayer(layer)
            .asDynamic()
            .build();
    }
    
    // Create a single entity with movement pattern at exact position
    flecs::entity createMovingEntity(const glm::vec3& pos) {
        return createMovingEntityWithType(pos, MovementType::RandomWalk);
    }
    
    // Create a single entity with specified movement type at exact position
    flecs::entity createMovingEntityWithType(const glm::vec3& pos, MovementType movementType) {
        glm::vec4 color = glm::vec4(0.8f, 0.8f, 0.8f, 1.0f); // Neutral start - dynamic colors will be applied
        
        // Entity spawns at exact mouse click position, movement pattern centered at click position
        MovementPattern pattern = createMovementPattern(pos, 0, 1, movementType);
        
        flecs::entity entity = create()
            .at(pos)  // Spawn at exact position
            .withColor(color)
            .asDynamic()
            .build();
            
        entity.set<MovementPattern>(pattern);
        return entity;
    }
    
    // Create a single entity at exact position (no radius offset)
    flecs::entity createExactEntity(const glm::vec3& pos, MovementType movementType = MovementType::RandomWalk) {
        glm::vec4 color = glm::vec4(0.8f, 0.8f, 0.8f, 1.0f);
        
        // Movement pattern centered at exact spawn position
        MovementPattern pattern = createMovementPattern(pos, 0, 1, movementType);
        
        flecs::entity entity = create()
            .at(pos)  // Exact position - no random offset
            .withColor(color)
            .asDynamic()
            .asPooled()
            .build();
            
        entity.set<MovementPattern>(pattern);
        return entity;
    }
    
    // Create swarm of entities with movement patterns
    std::vector<flecs::entity> createSwarm(size_t count, const glm::vec3& center, float radius) {
        return createSwarmWithType(count, center, radius, MovementType::RandomWalk);
    }
    
    // Create swarm of entities with specified movement type
    std::vector<flecs::entity> createSwarmWithType(size_t count, const glm::vec3& center, float radius, MovementType movementType) {
        std::uniform_real_distribution<float> angleDist(0.0f, 2.0f * M_PI);
        std::uniform_real_distribution<float> smallRadiusDist(0.0f, 0.5f); // Start very close to center for initial dispersal
        
        return createBatch(count, [&](EntityBuilder& builder, size_t i) {
            // Start entities very close to center for dispersal effect
            float angle = angleDist(rng);
            float r = smallRadiusDist(rng); // Very small initial radius
            glm::vec3 pos = center + glm::vec3(
                r * std::cos(angle),
                r * std::sin(angle),
                0.0f
            );
            
            // Use a neutral starting color - dynamic colors will be applied by movement system
            glm::vec4 color = glm::vec4(0.8f, 0.8f, 0.8f, 1.0f); // Neutral gray start
            
            // Create movement pattern that will disperse from center
            MovementPattern pattern = createMovementPattern(center, i, count, movementType);
            
            flecs::entity entity = builder.at(pos)
                   .withColor(color)
                   .asDynamic()
                   .asPooled()
                   .build();
                   
            // Add the movement pattern
            entity.set<MovementPattern>(pattern);
            
            return entity;
        });
    }
    
    // Cleanup pool
    void clearPool() {
        for (auto& entity : entityPool) {
            if (entity.is_valid()) {
                entity.destruct();
            }
        }
        entityPool.clear();
    }
};