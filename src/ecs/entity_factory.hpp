#pragma once

#include "entity.hpp"
#include "component.hpp"
#include <memory>
#include <functional>
#include <vector>
#include <random>

// Entity builder pattern for designer-friendly workflow
class EntityBuilder {
private:
    Entity entity;
    
public:
    EntityBuilder(Entity e) : entity(e) {}
    
    // Transform methods
    EntityBuilder& at(const glm::vec3& position) {
        if (auto* transform = entity.get_mut<Transform>()) {
            transform->setPosition(position);
        } else {
            entity.set<Transform>({.position = position});
        }
        return *this;
    }
    
    EntityBuilder& at(float x, float y, float z = 0.0f) {
        return at(glm::vec3(x, y, z));
    }
    
    EntityBuilder& rotated(const glm::vec3& rotation) {
        if (auto* transform = entity.get_mut<Transform>()) {
            transform->setRotation(rotation);
        } else {
            auto t = entity.get_mut<Transform>();
            if (!t) {
                entity.set<Transform>({});
                t = entity.get_mut<Transform>();
            }
            t->setRotation(rotation);
        }
        return *this;
    }
    
    EntityBuilder& scaled(const glm::vec3& scale) {
        if (auto* transform = entity.get_mut<Transform>()) {
            transform->setScale(scale);
        } else {
            auto t = entity.get_mut<Transform>();
            if (!t) {
                entity.set<Transform>({});
                t = entity.get_mut<Transform>();
            }
            t->setScale(scale);
        }
        return *this;
    }
    
    // Rendering methods
    EntityBuilder& withShape(Renderable::ShapeType shape) {
        if (auto* renderable = entity.get_mut<Renderable>()) {
            renderable->shape = shape;
            renderable->markDirty();
        } else {
            entity.set<Renderable>({.shape = shape});
        }
        return *this;
    }
    
    EntityBuilder& withColor(const glm::vec4& color) {
        if (auto* renderable = entity.get_mut<Renderable>()) {
            renderable->color = color;
            renderable->markDirty();
        } else {
            auto r = entity.get_mut<Renderable>();
            if (!r) {
                entity.set<Renderable>({});
                r = entity.get_mut<Renderable>();
            }
            r->color = color;
        }
        return *this;
    }
    
    EntityBuilder& withColor(float r, float g, float b, float a = 1.0f) {
        return withColor(glm::vec4(r, g, b, a));
    }
    
    EntityBuilder& onLayer(uint32_t layer) {
        if (auto* renderable = entity.get_mut<Renderable>()) {
            renderable->layer = layer;
            renderable->markDirty();
        } else {
            auto r = entity.get_mut<Renderable>();
            if (!r) {
                entity.set<Renderable>({});
                r = entity.get_mut<Renderable>();
            }
            r->layer = layer;
        }
        return *this;
    }
    
    // Physics methods
    EntityBuilder& withVelocity(const glm::vec3& linear, const glm::vec3& angular = glm::vec3(0.0f)) {
        entity.set<Velocity>({.linear = linear, .angular = angular});
        return *this;
    }
    
    EntityBuilder& withBounds(const glm::vec3& min, const glm::vec3& max) {
        entity.set<Bounds>({.min = min, .max = max});
        return *this;
    }
    
    // Lifetime methods
    EntityBuilder& withLifetime(float maxAge, bool autoDestroy = true) {
        entity.set<Lifetime>({.maxAge = maxAge, .autoDestroy = autoDestroy});
        return *this;
    }
    
    // Tag methods
    EntityBuilder& asStatic() {
        entity.add<Static>();
        entity.remove<Dynamic>();
        return *this;
    }
    
    EntityBuilder& asDynamic() {
        entity.add<Dynamic>();
        entity.remove<Static>();
        return *this;
    }
    
    EntityBuilder& asPooled() {
        entity.add<Pooled>();
        return *this;
    }
    
    // Finish building
    Entity build() {
        return entity;
    }
};

// Entity factory with pooling support
class EntityFactory {
private:
    flecs::world& world;
    std::vector<Entity> entityPool;
    std::mt19937 rng{std::random_device{}()};
    
    // Note: Dynamic colors are now generated by the movement system based on amplitude/frequency
    
    // Helper function to create fractal movement patterns
    MovementPattern createFractalPattern(MovementType type, const glm::vec3& center, float radius, size_t index, size_t totalCount) {
        MovementPattern pattern;
        pattern.type = type;
        // Don't set center here - let each entity use its own starting position
        
        // Create variation based on entity index
        float t = static_cast<float>(index) / static_cast<float>(totalCount);
        float goldenRatio = 1.618033988749895f;
        
        // More individualized parameters for character - 10x dispersal for pattern visibility
        pattern.amplitude = 2.0f + 6.0f * std::fmod(t * goldenRatio * 3.0f, 1.0f); // 10x larger amplitude for pattern visibility
        pattern.frequency = 0.3f + 1.5f * std::fmod(t * goldenRatio * 7.0f, 1.0f); // Varied speed
        pattern.phase = t * 6.28318530718f * 4.0f; // More phase variation
        pattern.timeOffset = t * 20.0f; // Stagger timing more
        
        // Sacred Geometry pattern-specific customization
        switch (type) {
            case MovementType::FlowerOfLife:
                pattern.circleRadius = 3.0f + 2.0f * t; // 10x larger for pattern visibility
                pattern.petalCount = 6; // Classic Flower of Life has 6 outer petals
                pattern.frequency *= 0.8f; // Slower, more meditative
                break;
                
            case MovementType::SeedOfLife:
                pattern.circleRadius = 2.5f + 1.5f * t; // 10x larger for pattern visibility
                pattern.petalCount = 7; // 7 circles in Seed of Life
                pattern.frequency *= 0.6f; // Even slower for contemplation
                break;
                
            case MovementType::VesicaPiscis:
                pattern.vesicaRatio = 0.866025f; // sqrt(3)/2 - sacred ratio
                pattern.frequency *= 1.2f; // More active lens movement
                break;
                
            case MovementType::SriYantra:
                pattern.frequency *= 0.4f; // Very slow, spiritual movement
                pattern.phaseShift = 0.05f * std::sin(t * 3.14f);
                break;
                
            case MovementType::PlatonicSolids:
                pattern.frequency *= 0.7f; // Moderate speed for geometric beauty
                break;
                
            case MovementType::FibonacciSpiral:
                pattern.spiralGrowth = 0.05f + 0.1f * t; // Varied growth rates
                pattern.frequency *= 0.5f; // Let the spiral unfold slowly
                break;
                
            case MovementType::GoldenRatio:
                pattern.goldenRatio = 1.618033988749f; // Ensure precise phi
                pattern.frequency *= pattern.goldenRatio * 0.3f; // Ratio-based frequency
                break;
                
            case MovementType::Metatron:
                pattern.circleRadius = 4.0f + 3.0f * t; // 10x larger varied cube sizes
                pattern.frequency *= 0.3f; // Slow, powerful movement
                break;
                
            case MovementType::TreeOfLife:
                pattern.frequency *= 0.25f; // Very slow, contemplative
                pattern.phaseShift = 0.02f; // Gentle phase evolution
                break;
                
            case MovementType::TetraktysFlow:
                pattern.frequency *= 0.9f; // Moderate Pythagorean rhythm
                break;
                
            default:
                break;
        }
        
        return pattern;
    }
    
public:
    EntityFactory(flecs::world& w) : world(w) {
        entityPool.reserve(1000); // Pre-allocate pool
    }
    
    // Create new entity or reuse from pool
    EntityBuilder create() {
        Entity entity;
        
        // Try to reuse pooled entity
        if (!entityPool.empty()) {
            entity = entityPool.back();
            entityPool.pop_back();
            
            // Clear existing components
            entity.clear();
        } else {
            entity = world.entity();
        }
        
        return EntityBuilder(entity);
    }
    
    // Return entity to pool for reuse
    void recycle(Entity entity) {
        if (entity.is_valid() && entity.has<Pooled>()) {
            // Clear components but keep entity alive
            entity.clear();
            entityPool.push_back(entity);
        }
    }
    
    // Batch creation methods for performance
    std::vector<Entity> createBatch(size_t count, std::function<void(EntityBuilder&, size_t)> configure) {
        std::vector<Entity> entities;
        entities.reserve(count);
        
        for (size_t i = 0; i < count; ++i) {
            auto builder = create();
            if (configure) {
                configure(builder, i);
            }
            entities.push_back(builder.build());
        }
        
        return entities;
    }
    
    // Predefined entity types for common use cases
    Entity createTriangle(const glm::vec3& pos, const glm::vec4& color, uint32_t layer = 0) {
        return create()
            .at(pos)
            .withShape(Renderable::ShapeType::Triangle)
            .withColor(color)
            .onLayer(layer)
            .asDynamic()
            .build();
    }
    
    Entity createSquare(const glm::vec3& pos, const glm::vec4& color, uint32_t layer = 0) {
        return create()
            .at(pos)
            .withShape(Renderable::ShapeType::Square)
            .withColor(color)
            .onLayer(layer)
            .asDynamic()
            .build();
    }
    
    // Create a single entity with sacred geometry movement pattern
    Entity createFractalEntity(const glm::vec3& pos, Renderable::ShapeType shape = Renderable::ShapeType::Triangle) {
        std::uniform_int_distribution<int> movementDist(0, 9); // 10 sacred geometry types
        std::uniform_int_distribution<int> shapeDist(0, 1);
        
        if (shape == Renderable::ShapeType::Triangle && shapeDist(rng) == 1) {
            shape = Renderable::ShapeType::Square;
        }
        
        int movementType = movementDist(rng);
        glm::vec4 color = glm::vec4(0.8f, 0.8f, 0.8f, 1.0f); // Neutral start - dynamic colors will be applied
        
        MovementPattern pattern = createFractalPattern(
            static_cast<MovementType>(movementType), 
            pos, 
            3.0f + 4.0f * std::uniform_real_distribution<float>(0.0f, 1.0f)(rng), // 10x larger random radius
            0, 
            1
        );
        
        Entity entity = create()
            .at(pos)
            .withShape(shape)
            .withColor(color)
            .asDynamic()
            .build();
            
        entity.set<MovementPattern>(pattern);
        return entity;
    }
    
    // Create swarm of entities with beautiful fractal movement patterns
    std::vector<Entity> createSwarm(size_t count, const glm::vec3& center, float radius) {
        std::uniform_real_distribution<float> angleDist(0.0f, 2.0f * M_PI);
        std::uniform_real_distribution<float> radiusDist(0.0f, radius);
        std::uniform_real_distribution<float> colorDist(0.0f, 1.0f);
        std::uniform_real_distribution<float> paramDist(0.0f, 1.0f);
        std::uniform_int_distribution<int> shapeDist(0, 1);
        std::uniform_int_distribution<int> movementDist(0, 9); // 10 sacred geometry types
        
        return createBatch(count, [&](EntityBuilder& builder, size_t i) {
            // Spread entities more naturally across the area
            float angle = angleDist(rng);
            float r = std::sqrt(radiusDist(rng)) * radius; // Square root for better distribution
            glm::vec3 pos = center + glm::vec3(
                r * std::cos(angle),
                r * std::sin(angle),
                0.0f
            );
            
            Renderable::ShapeType shape = shapeDist(rng) == 0 ? 
                Renderable::ShapeType::Triangle : Renderable::ShapeType::Square;
            
            // Use a neutral starting color - dynamic colors will be applied by movement system
            int movementType = movementDist(rng);
            glm::vec4 color = glm::vec4(0.8f, 0.8f, 0.8f, 1.0f); // Neutral gray start
            
            // Create movement pattern based on type - each entity gets its own character
            float goldenRatio = 1.618033988749895f;
            MovementPattern pattern = createFractalPattern(
                static_cast<MovementType>(movementType), 
                pos, // Use entity's starting position as reference
                5.0f + 5.0f * std::fmod(i * goldenRatio, 1.0f), // 10x larger varied movement radius
                i, 
                count
            );
            
            Entity entity = builder.at(pos)
                   .withShape(shape)
                   .withColor(color)
                   .asDynamic()
                   .asPooled()
                   .build();
                   
            // Add the fractal movement pattern
            entity.set<MovementPattern>(pattern);
            
            return entity;
        });
    }
    
    // Cleanup pool
    void clearPool() {
        for (auto& entity : entityPool) {
            if (entity.is_valid()) {
                entity.destruct();
            }
        }
        entityPool.clear();
    }
};